---
title: Riemann - Core Concepts
layout: default
---
<style>
  body {
background: #092eb7; /* Old browsers */
background: -moz-radial-gradient(center, ellipse cover,  #092eb7 0%, #040e47 100%); /* FF3.6+ */
background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#092eb7), color-stop(100%,#040e47)); /* Chrome,Safari4+ */
background: -webkit-radial-gradient(center, ellipse cover,  #092eb7 0%,#040e47 100%); /* Chrome10+,Safari5.1+ */
background: -o-radial-gradient(center, ellipse cover,  #092eb7 0%,#040e47 100%); /* Opera 12+ */
background: -ms-radial-gradient(center, ellipse cover,  #092eb7 0%,#040e47 100%); /* IE10+ */
background: radial-gradient(ellipse at center,  #092eb7 0%,#040e47 100%); /* W3C */
filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#092eb7', endColorstr='#040e47',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */
  } 
</style>

<div class="row">
  <h1 class="twelvecol">Riemann is an <span class="focus">event stream</span> processor.</h1>
</div>

<div class="row">
  <div class="fourcol">
    <p>Every time something important happens in your system, submit an event
    to Riemann. Just handled an HTTP request? Send an event with the time it
    took. Caught an exception? Send an event with the stacktrace. Small
    daemons can watch your servers and send events about disk capacity, CPU
    use, and memory consumption. Every second. It's like top for
    hundreds of machines at once.</p>
    
    <p class="callout">Riemann filters, combines, and acts on flows of events
    to understand your systems.</p>
  </div>

  <div class="eightcol last">
    <img src="images/riemann-arch-diagram.png" alt="Riemann archictecture diagram" />
  </div>
</div>

</div> <!-- main container -->
<div class="light">
  
<div class="container">
  <div class="row">
    <div class="sixcol">
      <h2>Events</h2>

      <p>Events are just structs. They're sent over Protocol Buffers, and
      in Riemann are treated as immutable maps. Each event has these
      (optional) fields:</p>

      <table>
        <tr>
          <th>host</th>
          <td>A hostname, e.g. "api1", "foo.com"</td>
        </tr>
        <tr>
          <th>service</th>
          <td>e.g. "API port 8000 reqs/sec"</td>
        </tr>
        <tr>
          <th>state</th>
          <td>Any string less than 255 bytes, e.g. "ok", "warning", "critical"</td>
        </tr>
        <tr>
          <th>time</th>
          <td>The time of the event, in unix epoch seconds</td>
        </tr>
        <tr>
          <th>description</th>
          <td>Freeform text</td>
        </tr>
        <tr>
          <th>tags</th>
          <td>Freeform list of strings, e.g. ["rate", "fooproduct", "transient"]</td>
        </tr>
        <tr>
          <th>metric</th>
          <td>A number associated with this event, e.g. the number of reqs/sec.</td>
        </tr>
        <tr>
          <th>ttl</th>
          <td>A floating-point time, in seconds, that this event is considered valid for. Expired states may be removed from the index.</td>
        </tr>
      </table>
    </div>
    
    <div class="sixcol last">
      <h2>The index</h2>
      <p>The index is a table of the current state of all services tracked by
      Riemann. Each event is uniquely indexed by its host and service. The
      index just keeps track of the most recent event for a given (host,
      service) pair.</p>
      
      <p>Streams run quickly and retain as little state as possible. The index
      is Riemann's state table; its picture of the world. The dashboard,
      network clients, and streams can all query the index to see what the
      system looks like now.  The <a href="dashboard.html">Dashboard</a> is
      just an HTML view of the index.</p>

      <p>Events entered into the index have a <code>:ttl field</code> which
      indicate how long that event is valid for. Events that sit in the index
      for longer than their TTL are removed from the index and reinserted into
      the event streams with state "expired". Instead of polling for failure,
      just let events expire. Services which fail to check in regularly can be
      handled by the same <a
        href="howto.html#detect-state-transitions">state-transition streams</a>
      you use for error handling.</p>
    </div>
  </div>

  <div class="row">
    <h2 class="twelvecol">Streams</h2>
  </div>

  <div class="row">
    <div class="sixcol">
      <p>Streams live in the <code>(streams ...)</code> section of your config
      file. You can think of <code>(streams)</code> as the <i>top level</i>
      stream, the source from which which all events flow. In this
      documentation, we'll often leave it implied.</p>
      
      <p>Here's a simple stream which sends critical events from any service
      beginning with "riak" to delacroix@vonbraun.com.</p>

{% highlight clj %}
(streams
  (where (and (service #"^riak")
              (state "critical"))
         (email "delacroix@vonbraun.com")))
{% endhighlight %}

      <p>The first argument to <code>where</code> is the <i>predicate</i>
      expression, which where uses to test each event. Events which match the
      predicate are passed to each of where's <i>children</i>, and if they
      don't match, nothing happens. In this case, there's one child the
      <code>email</code> stream.</p>

      <p>You can think of streams like rivers in the real world. Events flow
      through tributaries and streams, pool in lakes and dams, and are filtered
      by grates and boulders. Riemann streams aren't really <i>queries</i>;
      they're more like <i>pipelines</i> which events flow through.</p>
    </div>

    <div class="sixcol last">
      <img src="images/where-email.png" />
    </div>
  </div>

  <div class="row">
    <h2 class="twelvecol">Stream composition</h2>
  </div>

  <div class="row">
    <div class="twelvecol">
      <p>Let's consider a more complex problem. We want to send an email every
      time a service on a given host starts to report a new state; e.g., goes
      from reporting "ok", "ok", "ok", ... to "error", "error", "error". But in
      the event of a cascade failure we don't want to receive hundreds of
      emails--let's limit it to five per hour, and if more transitions occur,
      we'll roll them all up into the last email for that hour.</p>

      <p>Since streams are just <i>functions</i> which take events as
      arguments, they're composable. We'll chain together four streams to solve
      the problem.</p>
    </div>
  </div>


  <div class="row">
    <div class="sixcol">
      <p>We need to detect state transitions for each service <i>independently</i>, so we'll start by splitting the event stream with <code>(by)</code>.

{% highlight clj %}
(by [:host :service])
{% endhighlight %}

      <p>The (by) stream is like a river delta, or a fuel manifold. It splits
      the event stream into n distinct streams, each one independent. We get
      one fork for each unique host and service, so all the events from host 1
      and service
      1 flow together.</p>
    
      <p>Since we haven't given <code>(by)</code> any child streams yet, it'll
      just drop every event on the floor. Most streams can take any number of
      children, so it's common to see something like <code>(by [:host :service]
        (some-stream ...) (some-other-stream ...) ...)</code>.</p>
    </div>

    <div class="sixcol last">
      <img src="images/by-diagram.jpg" />
    </div>
  </div>


  <div class="row">
    <div class="sixcol">
      <p>For each one of those independent streams, we'll detect state
      transitions with <code>(changed)</code>.

{% highlight clj %}
(by [:host :service]
    (changed :state))
{% endhighlight %}

      <p>Whenever an event arrives with a <i>different</i> state than the
      previous event, <code>(changed :state)</code> passes on the new event to
      its children. Otherwise, nothing happens.</p>
    </div>

    <div class="sixcol last">
      <img src="images/changed-diagram.jpg" />
    </div>
  </div>


  <div class="row">
    <div class="sixcol">
      <p>With those state transitions, we'll roll up more than <code>5</code> events per <code>3600</code> seconds. In a given hour, rollup will allow four events to pass through immediately. Then it aggregates all successive events in a buffer, which is passed on at the end of the hour.</p>

{% highlight clj %}
(by [:host :service]
    (changed :state
             (rollup 5 3600
                     (email "delacroix@vonbraun.com"))))
{% endhighlight %}

      <p>Rollup's child is an <code>(email)</code> stream, which emails events it receives to Delacroix. I think there's a problem in the sim units today!</p>
    </div>

    <div class="sixcol last">
      <img src="images/rollup-diagram.jpg" />
    </div>
  </div>
  
  <div class="row">
    <div class="twelvecol">
      <p class="callout">To learn more, see the <a
        href="howto.html#working-with-streams">howto articles on streams</a>,
      and check out the <a href="api/riemann.streams.html">Streams API</a> for
      details.</p>
    </div>
  </div>

  <div class="row">
    <div class="sixcol">
      <h2>Queries</h2>
      
      <p>Clients can query the index for particular events using a simple query
      language. Dashboard views are each powered by a single query. Queries can
      be applied on the index of past events, but can also tap into the stream
      of events going to the index in real-time.</p>

{% highlight clj %}
# Simple equality
state = "ok"

# Wildcards
(service =~ "disk%") or 
(state != "critical" and host =~ "%.trioptimum.com")

# Standard operator precedence applies
metric_f > 2.0 and not host = nil

# Anything with a tag "product"
tagged "product"

# All states
true
{% endhighlight %}

      <p>Query messages return a list of matching events. The full grammar is <a
        href="https://github.com/aphyr/riemann/blob/master/src/riemann/Query.g">here</a>.</p>
    </div>

    <div class="sixcol last">
      <h2>Servers</h2>

      <p>"Riemann" usually refers to the JVM process that handles events, i.e.
      <code>bin/riemann</code>. Internally, that process has several distinct
      servers which are specified in the configuration file.</p>
     
      <p>The TCP and UDP servers listen on port 5555 for TCP connections and
      UDP datagrams. They accept a stream of protocol buffer <i>messages</i>
      containing <i>events</i> (or queries, control messages, etc). Those
      events are then applied to a tree of <i>streams</i>. The TCP server also
      supports querying the index for the current state of the system. The UDP
      protocol is much faster but lossy.  The TCP protocol is slower, but
      provides reliable delivery and acknowledgement of receipt.</p>

      <p>The websockets server (ws-server) accepts HTTP websockets connections.
      This server streams events which match a given query to clients.</p>
    </div>
  </div>

</div>
