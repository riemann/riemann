---
title: Riemann - Contributing
layout: default
---
<h1>(apply within <span class="focus">hackers</span>)</h1>

<p>I built Riemann to solve my problems, but I want it to work for you,
too. If you use Riemann, <a href="mailto:aphyr@aphyr.com">send me an
  email</a> about how it's working for you, or what needs to change</a>. Frustrated with the API? Find a bug? <a href="https://github.com/aphyr/riemann/issues">Open an issue</a>.</p>

<p class="callout">The best way to say "thank you" is to contribute code. <a href="https://github.com/aphyr/riemann">It's all on Github</a>.</p>

<div class="cards">
  <div class="card">
    <h2>Building</h2>
    <code><pre>git clone git://github.com/aphyr/riemann.git</pre></code>

    <p>Riemann uses <a
      href="https://github.com/technomancy/leiningen">Leiningen 2</a>, the
    Clojure build tool. First, fetch dependencies:</p>

    <code><pre>lein deps</pre></code>

    <p>Build the java query parser:</p>
    <code><pre>lein javac</pre></code>

    <p>And run the test suite:</p>
    <code><pre>lein test</pre></code>

    <p>Or, for a specific namespace:</p>
    <code><pre>lein test riemann.test.streams</pre></code>

    <p>Tests for graphite and email integration:</p>
    <code><pre>lein test :integration</pre></code>

    <p>Benchmarking tests will generate graphs in bench/.</p>
    <code><pre>lein test :bench</pre></code>

    <p>I'm really sorry about this, but there are some poorly-written
    tests for time-dependent streams like rates and percentiles. These
    can be finicky; I'm working on rewriting them as soon as possible.
    Some tests also rely on a local graphite install or sendmail; you can
    ignore them if you aren't changing those components.</p>

    <p>You can run the server with</p>

    <code><pre>lein run -- riemann.config</pre></code>

    <p>and when you're ready to package, just <code>lein package</code>
    to build both regular and standalone jars, a debian package, tarball,
    and pom.xml.</p>

    <p>The protocol buffers code and client are a part of riemann-java-client.
    You'll need <a
      href="http://code.google.com/p/protobuf/downloads/detail?name=protobuf-2.3.0.tar.bz2&can=2&q=">protoc
      2.3.0</a> to build riemann-java-client. When you're hacking locally:</p>

    <code><pre>git clone git://github.com/aphyr/riemann-java-client.git
cd riemann-java-client
mvn package
mvn install</pre></code>

  </div>

  <div class="card">
    <h2>Pull Requests</h2>
    
    <p>When you've made your changes (for anything non-trivial, on a
    topic branch, please), send me a pull request on Github. Please run
    the test suite before submitting, and keep your commits focused.</p>
  </div>

  <div class="card">
    <h2><a name="protocol" style="color: inherit">Protocol</a></h2>
    
    <p>A connection to Riemann is a stream of messages. Each message is a
    4 byte network-endian integer *length*, followed by a Protocol Buffer
    Message of *length* bytes. See <a
      href="https://github.com/aphyr/riemann-java-client/blob/master/src/main/proto/riemann/proto.proto">the
      protocol buffer definition</a> for the details.</p>

    <p>Over UDP, the length header is omitted; just send the protobuf
    directly. UDP datagrams have a default maximum size of 16384 bytes by
    Riemann's default; larger messages should go over TCP. This limit is
    configurable in both the client and server.</p>

    <p>The server will accept a repeated list of Events, and respond with
    a confirmation message with either an acknowledgement or an error.
    Check the `ok` boolean in the message; if false, message.error will
    be a descriptive string.</p>

    <p>Because protocol buffers is strongly typed, the metric field is
    represented on the wire as metric_f. At some point I'll add an int64
    as well.</p>

    <p>Events are uniquely identified by host and service. Both allow
    null.  Event.time is the time in unix epoch seconds and is optional.
    The server will generate a time for each event when received if you
    do not provide one. I don't need time resolution finer than 1 second
    presently, but if you do, my plan is to add a nanosecond field as
    well.</p>

    <p>You can also query events from the index using a basic query
    language. Just submit a Message with your query in
    message.query.string. Search queries will return a message with
    repeated Events matching that expression. A
null expression will return no states.</p>
  </div>

  <div class="card">
    <h2>Thanks</h2>

    <p>Pierre-Yves Ritschard (pyr) formalized the protocol for riemann servers
    and split up the riemann.server namespace into distinct, modular
    transports.</p>

    <h3>0.1.5</h3>

    <p>Ben Firshman reported a critical bug in (where).</p>

    <h3>0.1.4</h3>

    <p>jib and lwf pointed out that Cheshire would fix some JSON encoding
    problems.</p>

    <p>jib and hhenkel reported issues with various JVM flags.</p>

    <p>Dave Cottlehuber (dch) changed riemann-health to report comm instead of
    full process args in cpu descriptions.</p>

    <p>Pierre-Yves Ritschard (pyr) put together a simple Riemann grid at
    Exoscale, corrected documentation on lein run, and fixed a bug in
    graphite-server.</p>

    <h3>0.1.3</h3>

    <p>Jos Bourmans (jib) helped clarify Riemann's documentation, fixed
    streams, and made /usr/bin/riemann properly exec java.</p>

    <p>Henrik Nordvik (zerd) fixed a few bugs in riemann-health's OS X
    support.</p>

    <p>Banjiewen fixed a memory leak in moving-event-window, and reworked the
    Netty socket handler.</p>

    <p>David J Rusek wrote a new Java client for Riemann, based on Netty and
    Guaava futures.</p>

    <p>Pierre-Yves Ritschard improved (coalesce), cleaned up some code in
    riemann.common, added Travis-CI support, a Graphite-compatible server, and
    improved performance of pubsub. He added performance tests for the index.</p>

    <p>William Jimenez added a KVM monitor to riemann-tools.</p>

    <p>lwf added custom tags to riemann-tools, as well as riemann-diskstats.</p>

    <p>Derek Perez added Redis, Haproxy, and Cloudant monitors to
    riemann-tools, plus countless other commits. Rock on, man!</p>

    <p>Carl Yeksigian of Blue Mountain Capital published a C# client.</p>

    <p>Jake Luciani of Blue Mountain Capital contributed a Cassandra
      watcher.</p>

    <p>Ben Black contributed streams for fast reduction of events and metrics
    over time, experimented with integrating Parallel Colt, and suggested
    windowing API ideas.</p>

    <p>Gareth Rushgrove made it easier for folks to get started with
    Riemann-dash by fixing typos, adding 1.8 compatibility, and writing
    a puppet module.</p>

    <p>Edward Ribeiro refactored riemann-java-client's reporting.</p>

    <p>Derek Perez wrote a node.js client</p>

    <p>Joeseph Abrahamson, of Reify Health, wrote an Erlang client: Zeta.</p>

    <p>Joe Caswell added FreeBSD and Darwin support to riemann-health.</p>

    <p>Michael Klishin (antares) helped get Riemann's build process up to
    speed with Leiningen 2.</p>

    <h3>0.1.2</h3>

    <p>Michael Bernstein (mrb) got Riemann running on Clojure 1.4 and Lein2.</p>

    <p>Brian Shumate corrected a non-portable shebang line.</p>

    <p>Jeremy Carroll pointed out my evil lies in the configuration guide.</p>

    <h3>0.1.1</h3>
    
    <p>Michael Fairley added a hostname override to RiemannReporter.</p>
    
    <p>Edward Ribeiro improved concurrency in the Java client and fixed lots of
    little bugs, misphrasings, and typos.</p>

    <p> Tom Crayford pointed out a typo.</p>

    <p>Benjamin Anderson (banjiewen) wrote a new Python client.</p>

    <p>Steve Losh (sjl) wrote streams/fill-in-last and polished several rough
    edges in common, streams, and periodic. Steve also expanded the adjust
    stream to take a function which arbitrarily transforms entire events.</p>

    <p>MÃ¥rten Gustafson started work on the Java client, added timeouts, and
    tests.</p>

    <p>Paul Butcher fixed a typo in the quickstart.</p>

    <p>Obfuscurity and Lusis contributed ideas for HA failover and peer
    discovery.</p>

    <p>Lusis wrote an adapter between <a
      href="http://logstash.net/">logstash</a> and Riemann.</p>

    <p>Eric Lindvall (lindvall) updated riak-ruby-client to be
    1.8-compatible.</p>

    <h3>0.1.0</h3>

    <p>#flatland, #clojure and #leiningen, including jodaro, ninjudd,
    raynes, and amalloy, helped with protobufs parsing, leiningen, and
    general Clojure questions.</p>

    <p><a href="http://showyou.com">Showyou</a>, my employer, gave me the
    infrastructure I needed Riemann for, and the chance to share it with
    the world.</p>

    <p>John Mullerleile (jrecursive) was deeply involved in talking
    through the concept and structure of Riemann, as well as advice
    around the JVM and profiling.</p>

    <p>C Scott Andreas (cscotta) and the <a
      href="http://boundary.com">Boundary</a> crew gave many helpful
    suggestions around the JVM, Maven, high_scale_lib, and profiling. Our
    conversations yielded many references, algorithms and ideas.</p>

    <p>Allen Rohner (arohner) on #clojure offered a logging configuration
    snippet.</p>

    <p>Ryan Grove and Sean Cribbs gave feedback on documentation and
    design.</p>

    <p>Reid Draper contributed a syntactic patch.</p>

    <p>Sam Newman (snewman) brought Riemann up to speed with Clojure
    1.3.</p>

    <p>Tyler Schuett offered graphic design advice.</p>

    <p>Gleicon wrote the Python client.</p>
  </div>
</div>
