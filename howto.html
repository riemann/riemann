---
title: Riemann - Howto
layout: default
---

<style>
  body {
    background: #ff9000; /* Old browsers */
    background: -moz-radial-gradient(center, ellipse cover,  #ff9000 0%, #d14c00 100%); /* FF3.6+ */
    background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#ff9000), color-stop(100%,#d14c00)); /* Chrome,Safari4+ */
    background: -webkit-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Chrome10+,Safari5.1+ */
    background: -o-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Opera 12+ */
    background: -ms-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* IE10+ */
    background: radial-gradient(ellipse at center,  #ff9000 0%,#d14c00 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ff9000', endColorstr='#d14c00',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */
  }
</style>

<div class="row">
  <h1 class="twelvecol">A <span class="focus">guide</span> to working with Riemann</h1>
</div>

<div class="row">
  <div class="sixcol">
    <p>This is not a comprehensive guide to everything in Riemann, but it can
    get you started and help solve specific problems. Want to add your own
    article to this page? <a href="#help-write-documentation">Send me a pull
      request!</a></p>
  </div>

  <div class="sixcol last">
    <p>Once you know where to look, you can learn more by reading the <a
      href="api">API docs</a> (especially <a
      href="api/riemann.streams.html">riemann.streams</a>), and <a
      href="https://github.com/aphyr/riemann/tree/master/src/riemann">the
      source</a>.  I try hard to write readable code. The <a
      href="https://github.com/aphyr/riemann/tree/master/test/riemann">test
      suite</a> is also a great place to look for use examples.</p>
  </div>
</div>

</div><!-- container -->
<div class="light">

<div class="container">

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function() {
      $("#toc").tableOfContents(null, {
        startLevel: 2,
        depth: 2,
        topLinks: true
      });
    });
  </script>

  <div class="row">
    <div class="twelvecol">
      <div id="toc">
      </div>
    </div>
  </div>

  <div class="row">
    <div class="twelvecol">

<h2>Running Riemann</h2>

<div class="row">
  <div class="sixcol">
    <h3>Changing the config</h3>
    <p>If you use the Debian or Centos packages, Riemann adds a
    <code>riemann</code> user, stores its configuration in
    <code>/etc/riemann/riemann.config</code>, and logs to
    <code>/var/log/riemann.log</code>. You should always tail the log file when
    working with Riemann; it'll alert you to configuration errors and help you
    debug your streams.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
tail -F /var/log/riemann.log
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In another terminal, use your favorite editor to open
    <code>/etc/riemann/riemann.config</code>. Let's add a logging stream, so we
    can see all events that pass through the streams. <code>#(info %)</code>
    expands into <code>(fn [x] (info x))</code>, which is a function that takes
    an event and logs it at the INFO log level.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  index
  ...
  #(info "received event" %))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we need to reload the config file. Riemann will respond to SIGHUP,
    or you can use the init scripts. You'll see a message about reloading the
    config in the Riemann log. If you make a mistake, like a syntax error,
    Riemann will continue running with the old config and won't apply the new
    one. Instead, it'll log an explanation of the problem, so you can
    investigate and fix it.</p>

    <p>Now that the config has been reloaded, you should see events flowing by
    in the log. Some come from external sources, like riemann-health or your
    own programs. Others are generated by Riemann internally, as a part of its
    internal performance instrumentation. You can insert logging statements
    anywhere in your streams to verify what kind of events are flowing through
    that point.</p>

    <p>Reloading is experimental, and is subject to the normal Clojure rules
    about <code>(def)</code> and <code>(defn)</code>. To avoid confusion, use
    <code>let</code> bindings instead of <code>def</code>; it'll guarantee
    reloads work correctly. If reloads seem broken, you might need to do a
    full restart for your changes to take effect.</p>
  </div>

  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<h3>Putting Riemann into production</h3>
<div class="row">
  <div class="sixcol">
    <p>Riemann has three main parts: clients, the server, and dashboard. By
    default, all listen on the loopback interface. You'll need to configure
    each to listen to an appropriate interface for your environment. On the
    host that runs the Riemann server, open
    <code>/etc/riemann/riemann.config</code>, and change the host that Riemann
    binds to. To listen on all interfaces, use <code>0.0.0.0</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))
{% endhighlight %}
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>Now we need to reload Riemann to tell it about our changes.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>To change the address that the dashboard binds to, see <a href="https://github.com/aphyr/riemann-dash">riemann-dash's README</a>.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-dash only serves some JS code and a small piece of
    configuration; the browser connects directly to Riemann's websocket server
    to receive events. To connect the dashboard to a remote Riemann server,
    double-click the text box in the top right of the dashboard, and change the
    address from <code>127.0.0.1:5556</code> to your Riemann server's host and
    port. When you hit enter, the browser will initiate a websocket connection
    to that address and begin displaying events. Hit <code>s</code> to save the
    new dash config; the dashboard will connect to that address every time you
    load the page.</p>

    <p>If the dashboard is unable to connect to the Riemann websocket server,
    you'll see an alert pop up every few seconds. Check that the server is
    running, that the Riemann websocket server is reachable from your browser,
    that you used the correct host and port, and so on.<p>

    <p>If you don't see *anything* on the dash, but it connected successfully,
    you may not have any events to show, or you may not have set up any
    views.</p>
  </div>
</div>

<div class="row">
  <h3>Change the log file</h3>

  <div class="sixcol">
    <p>To log to a file, just say</p>

{% highlight clj %}
(logging/init {:file "/path/to/some/riemann.log"})
{% endhighlight %}

    <p>If you'd prefer to only log to the console, just leave out :file</p>

{% highlight clj %}
(logging/init)
{% endhighlight %}
  </div>
</div>

<div class="row">
<h3>Overriding Riemann functions</h3>

<div class="sixcol">
  <p>Sometimes, something in Riemann doesn't work the way you'd like. When this
  happens, you can redefine any function in Riemann in the config file. Just
  switch to the appropriate namespace, redefine the function, and switch back to
  <code>riemann.config</code>.</p>

  <p>For instance, let's say you wanted to change how emails are formatted. The
  namespace <code>riemann.common</code> has a function called <code>body</code>,
  which accepts a sequence of events and returns a string. We'll override it in
  our config file:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(ns riemann.common)
(defn body [events]
  ; pr-str formats events as a clojure-readable string.
  (pr-str events))
(ns riemann.config)

; And then your servers, streams, etc...
(tcp-server ...)
(streams ...)
{% endhighlight %}
  </div>
</div>

<h3>Fault tolerance</h3>

<div class="row">
  <div class="sixcol">
    <p>Because Riemann performs arbitrary computation over the event stream,
    with side effects, it <i>cannot</i> be distributed safely. You can,
    however, distribute it somewhat less than safely--a technique aligned with
    Riemann's philosophy that "mostly correct information <i>right now</i> is
    more useful, than totally correct information only available once the
    failure is over."</p>

    <p>One obvious distribution strategy is to place two Riemann nodes on the
    same switch and have them share a virtual IP address using, say, Heartbeat
    or Corosync. On resource acquisition, the node allocating the IP should
    issue a gratuitous arp broadcast over that interface advertising the new
    route to the relevant switch(es). Failover in this case looks essentially
    like restarting a Riemann node, which should be relatively painless--most
    Riemann deployments fill in missing state within a few seconds to
    minutes.</p>

    <p>What happens if the nodes are isolated by a network partition and both
    claim the interface? Depends on your network, but the answer is "probably
    not good things". OTOH, there's no good way for *any* consensus algorithm
    in an asynchronous network to make latency-bounded decisions in a safe way.
    FLP rears its ugly head. You're going to lose data in the short term; the
    question is how to emit as much useful, actionable information as possible,
    so you can fix the problem.</p>

    <p>I've got a sketch worked out for a highly-available clustered Riemann
    which tries to negotiate these tradeoffs in a sane way, but it involves
    minimum latency costs, severe throughput costs (I'm estimating three to
    five orders of magnitude slower), disk IO, all kinds of esoteric failure
    modes, and some moderately challenging mathematics. It'd take a long time
    to build and would require some serious educational work on my part.
    There's just no way around it: distributing arbitrary latency-bounded
    computation is hard. You're going to have to reason about consensus. I'm
    really sorry about this. :(</p>
  </div>
</div>

<h3>Sharding</h3>

<div class="row">
  <div class="sixcol">
    <p>Because Riemann performs arbitrary computation, it can't shard your
    workload automatically. You'll need to pick some axes along which to shard,
    perform local aggregation on those nodes, and reduce the results with some
    higher-level Riemann node. The <code>forward</code> stream can help you
    connect nodes to one another, and <code>async-queue!</code> can allow some
    elasticity around latency jitters and downstream node restarts, but the
    actual sharding and discovery mechanics you'll have to build yourself.</p>
  </div>
</div>

<h3>Connecting to the REPL</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann has an nREPL server built in. You can enable this in your config
    with:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(repl-server {:host "127.0.0.1"})
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can then use Leiningen 2 to connect to it.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
git clone git://github.com/aphyr/riemann.git
cd riemann
lein repl :connect 127.0.0.1:5557
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can reload the config by sending Riemann a SIGHUP, but you can also
    do it from the REPL.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
user=> (riemann.bin/reload!)
{% endhighlight %}
  </div>
</div>

<h2>Debugging</h2>

<h3>Troubleshooting missing events</h3>

<div class="row">
  <div class="sixcol">
    <p>First, determine whether the events you're looking for are actually
    making it into Riemann. This will help localize the problem to the
    <i>network</i> or the <i>streams</i>. Add a new top-level stream which
    simply logs all inbound events. Use a <code>(where)</code> filter around
    that logging stream to cut down on noise.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  #(info %))
{% endhighlight %}

{% highlight clj %}
(streams
  (where (service "some thing you're looking for")
    #(info %)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If you don't see the events you're looking for in the logs, they must
    be dropped <i>before</i> arriving at the streaming system. Check:</p>

    <ul>
      <li>Riemann clients are sending to the correct Riemann host and port.</li>
      <li>Riemann is listening to that host and port. Check <code>(tcp-server)</code> and <code>netstat -lntp | grep riemann</code>.</li>
      <li>The network can relay packets from the client machine to the Riemann
      server. Use <code>telnet some.host 5555</code> or <code>nmap -sT
        some.host -P 5555</code>.</li>
      <li>Your packets are making it from the client to the server. UDP
      messages can be dropped, delayed, duplicated, or re-ordered at any time
      by the network, or discarded if the receiving node's receive buffer is
      too full. Try using TCP.</li>
    </ul>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If your messages <i>are</i> arriving in the streaming system, but aren't
    making it to the index or other output streams, gradually slide the
    <code>#(info %)</code> stream downstream towards the exit point, to verify
    at which point in the chain the events are not what you expect.</p>

    <p>If you're indexing events, but they don't appear in queries, they may
    have expired from the index. Try <code>(expired #(warn "expired" %))</code>
    to warn about expired events. They may be expiring because their TTL is
    shorter than the interval between events. They may also expire because the
    Riemann clock is in the future relative to the originating event, due to
    clock skew or network/processing latency.</p>

    <p>Check the internal instrumentation for the Riemann queue depth and core
    latencies; if the queue is more than a handful of events deep, or stream
    latencies are on the order of the relevant event TTLs, you might need to
    reduce the load on the Riemann server or investigate downstream services
    that might be slow.</p>

    <p>Check clock skew between nodes using <code>watch date</code> or similar.
    Make sure your clocks are in UTC, <i>not</i> local time. Never local time.
    <i>Especially</i> never Daylight Savings Time. You can use Riemann's
    <code>clock-skew</code> stream to measure clock skew as seen by the Riemann
    node as well.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  #(info %) ; First, measure here
  (where (service #"^riak .+")
    #(info %) ; Then move the info stream here to check the filter
    (by :service
      (coalesce
        #(info %) ; Third, check the coalesced vector of events
        (smap folds/max
          #(info %) ; Fourth, probe here to check the maximum calculation
          (with :host nil
            #(info %) ; Finally, check exactly what events are being applied
                      ; to the index.
            index))))))
{% endhighlight %}
  </div>
</div>

<h2>Instrumenting your systems</h2>

<h3>Measure Riemann itself</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann comes with instrumentation built-in, which is sampled
    periodically and injected into the event stream. You can query the
    dashboard for <code>service =~ "riemann %"</code> to see Riemann's internal
    metrics. All latencies are in milliseconds.</p>

    <p><code>riemann streams</code> refers to the stream processor: its
    throughput measures the number of events being passed to <code>(streams
      ...)</code> per second, and its latencies indicate the time it takes to
    process a single event through the streaming system.</p>

    <p>The TCP, UDP, and Websockets servers instrument their throughput and
    latency where possible. TCP latency measures the time from initial message
    deframing to Netty write of the corresponding response. For instance,
    <code>riemann server tcp 1.2.3.4:5555 in latency 0.95</code> measures the
    95th percentile time, in milliseconds, for the TCP server on port 5555 to
    parse, queue, process, and dispatch a response for a message.  The rate for
    servers measures *message* rate, not *event* rate.</p>

    <p>The main queue connecting Netty IO threads to the parsing/execution
    threadpool is measured by <code>riemann netty execution-handler queue
    size</code>, and is a critical measure of whether the streaming system is
  overloaded relative to inbound request load.</p>

    <p>To disable instrumentation, or control how often events are sampled, see
    <a
      href="http://riemann.io/api/riemann.config.html#var-instrumentation">riemann.config/instrumentation</a>.</p>
  </div>
</div>

<h3>Measure CPU, memory, and disk use</h3>

<div class="row">
  <div class="sixcol">
    <p><a href="https://github.com/aphyr/riemann-tools">Riemann-tools</a>
    includes a program called riemann-health, which measures the local host's
    cpu, memory, and disk use. You can install it from rubygems.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
gem install riemann-tools
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>... and run riemann-health with the address of your riemann server like
    so:</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
riemann-health --host 1.2.3.4
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-health reports utilization <i>fractions</i> by default, ranging
    from zero to one. Load average is divided by the number of cores, and disk
    use by capacity. You can adjust the polling interval, what percentage of
    cpu use is considered critical, and more. <code>riemann-health
    --help</code> will tell you more.</p>
  </div>
</div>

<h3>Monitor Riak</h3>

<div class="row">
  <div class="sixcol">
    <p><a href="https://github.com/aphyr/riemann-tools">Riemann-tools</a>
    includes riemann-riak, which uses riak's HTTP stats interface, some
    filesystem checks, and optionally, some erlang RPC requests to measure
    Riak's get and put latencies, request throughput, ring status, and disk
    use. Run riemann-riak on each Riak node.</p>

    <p>Riemann-riak comes with defaults for the riak .deb packages shipped by
    Basho, but it's tunable for other configurations. See <code>riemann-riak
    --help</code> for more options.</p>
  </div>
  <div class="sixcol last">
    {% highlight sh %}
    gem install riemann-tools
    riemann-riak --host 1.2.3.4
    {% endhighlight %}
  </div>
</div>

<h3>Custom event attributes</h3>

<div class="row">
  <div class="sixcol">
    <p>You can include arbitrary additional fields in Riemann
    events. These are not a replacement for service, host, and time: the
    composite primary key of a logical "thing" in the Riemann universe, but
    they *do* let you more easily aggregate and filter events, or carry richer
    contextual information associated with a single message.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In most clients you can simply pass an extra key and value in the event
    map. In strongly-typed clients like riemann-java-client, special methods
    like EventDSL.attribute(key, value) are present.</p>
  </div>

  <div class="sixcol last">
{% highlight rb %}
client << {service: "thumbnailer rate",
           metric:  5.0,
           build:   "7543"}
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Custom attributes are always encoded as strings in Protocol Buffers
    (pull request welcome!), but you can replace them with parsed variants in
    your streams using smap, adjust, and friends.</p>

    <p>In the Riemann server, custom attributes work just like normal
    attributes on events--they're just a bit slower, owing to the hashmap
    lookup. Just like normal fields, you can use get, assoc, dissoc, update,
    and all the other Clojure functions over maps. Custom attributes do *not*
    have shorthand syntax in <code>(where)</code> (to prevent arbitrary symbol
    capture), but are accessible through <code>(:my-field event)</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "thumbnailer rate")
  ; Convert build numbers from strings to longs
  (adjust [:build #(Long. %)]
    ; Compute a throughput for each specific build
    (by :build
      (smap #(assoc % :service (str (:service %) " build " (:build %)))
        (rate 5 index)))

    ; Or maybe an old version reported numbers that were 2x larger than they
    ; should have been
    (where (< (:build event) 1055)
      (scale 1/2 index)
      (else index))))
{% endhighlight %}
  </div>
</div>

</div>

<h2>Working with streams</h2>

<h3>Split streams</h3>

<div class="row">
  <div class="sixcol">
    <p>Splitting streams is the default in Riemann. Almost all streams, unless
    otherwise documented, take any number of child streams as their final
    arguments, and forward the same events on to all of them.  Because Riemann
    uses Clojure's immutable data structures, you don't have to worry about
    locking or mutation. Streams "change" events by sending altered,
    shared-structure *copies* of events downstream. For instance, this where
    expression sends matching events to <i>two</i> child streams; one of which
    indexes a copy of the event with service "foo", and the other with service
    "bar".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (host "db04")
  (with :service "foo" index)
  (with :service "bar" index))
{% endhighlight %}
  </div>
</div>

<h3>Combine streams</h3>

<div class="row">
  <div class="sixcol">
    <p>Sending events from two places to the same stream is simple: just bind
    the stream to a variable. In Clojure, <code>(let [x 1 y 2] ...)</code>
    assigns <code>x</code> to <code>1</code> and <code>y</code> to
    <code>2</code> everywhere inside the <code>let</code> expression. Since
    streams are values, you can bind them to variables too. For instance, this
    code has two paths--one for http and one for 0mq--which flow into the same
    rate stream, and from there to the index.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (index)
      aggregate (rate 5 index)]
  (where (service "http req rate")
    aggregate)
  (where (service "0mq req rate")
    (scale 2 aggregate)))
{% endhighlight %}
  </div>
</div>

<h3>Distinct streams for each host, service, etc.</h3>

<div class="row">
  <div class="sixcol">
    <p>Often, you want to run *many copies* of a particular stream; say,
    computing a rate for each service separately, or each [host, service] pair.
    Use <code>by</code> to bifurcate a stream into distinct copies based on a
    function or vector of functions of that event. For instance, to sum up disk
    use across hosts, but retaining a distinct sum for each service, you could
    write:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(by :service
  (coalesce
    (smap folds/sum
      (with :host nil
        index))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Or to compute a rate for each distinct host and service:
  </div>
  <div class="sixcol last">
{% highlight clj %}
(by [:host :service]
  (rate 5 index))
{% endhighlight %}
  </div>
</div>

<h3>Filter events</h3>

<div class="row">
  <div class="sixcol">
    <p>Often, we want to do some operation only on a subset of events flowing
    through a stream. For instance, we might only want to email events which
    have the state "error". The basic filtering streams are <a
    href="api/riemann.streams.html#var-where">where</a>, her less magical
    sister <a href="api/riemann.streams.html#var-where*">where*</a>, <a
      href="api/riemann.streams.html#var-match">match</a>, <a
      href="api/riemann.streams.html#var-tagged-all">tagged-all</a> and <a
      href="api/riemann.streams.html#var-tagged-any">tagged-any</a>, and <a
      href="api/riemann.streams.html#var-expired">expired</a>. Most of the
    time, you'll use <code>where</code>.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where takes a <i>predicate</i>, which is a special expression for
    matching events. After the predicate, <code>where</code> takes any number
    of child streams, each of which will receive events which the predicate
    matched. For example, we could email only events which have state
    "error".</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (state "error")
    ; Only events which have the state "error" are passed on to the email
    ; stream:
    (email "delacroix@vonbraun.com")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where expressions can match particular values of a field; like passing
    on events which occur only on the Von Braun:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (host "von braun") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Regular expressions (in Clojure, strings like <code>#"foo .+"</code>) can be used to match fields as well.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (description #"an+elids") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can filter for the presence of a given tag.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (tagged "mutant") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>There are also streams specifically for selecting events which have
    some, or all, of a set of tags. Tagged is shorthand for tagged-all.</p>

  </div>
  <div class="sixcol last">
{% highlight clj %}
(tagged-any ["cat" "dog"] (with :service "animals/sec" (rate 1 index)))
(tagged-all ["ops" "ddos"] (email "ops@githug.com"))

(tagged "page" page-ops)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Numeric functions work like you'd expect:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(where (>= (* metric 1000) 2.5))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Which makes range queries easy:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (< 5 metric 10))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Predicates can use any function or macro, including boolean operators.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (not (or (tagged "www")
                (and (state "ok") (nil? metric)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can also define and use arbitrary functions in your predicates.
    (where) binds the variable <code>event</code> to the event being
    considered.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn global? [event] (nil? (:host event)))
(where (global? event))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Higher-order functions work like you'd expect, so you can happily map,
    fold, filter, etc inside a where predicate too. For instance, we can match
    any of several regular expressions:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (some (fn [r] (re-find r service)) [#"cassandra disk .+"
                                           #"cassandra net .+"
                                           #"cassandra latency \d+"])
  ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where streams forward an event to their children when the predicate
    matches.  When the predicate *doesn't* match, where will forward events to
    any children in an <code>(else)</code> block.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (or (service "ok") (service "warning"))
  index
  (else
    (email "ops@foo.com")))
{% endhighlight %}
  </div>
</div>

<h3>Set thresholds</h3>

<p>You can use (where) to alert you when a metric goes out of bounds. Where the
metric falls between zero and five, inclusive, index it with state "ok".
Otherwise, index it with "warning":</p>

{% highlight clj %}
(streams
  (where (<= 0 metric 5)
    (with :state "ok" index)
    (else
      (with :state "warning" index))))
{% endhighlight %}

<h3>Detect state transitions</h3>

<p>The <a href="api/riemann.streams.html#var-changed">changed</a> stream
forwards on events when some fields of that event change. For instance, you
can send an email whenever the state changes:</p>

{% highlight clj %}
(streams
  (by [:host :service]
    (changed :state
      (email "ops@startup.io"))))
{% endhighlight %}

<p>Note that we use <code>(by)</code> so that each distinct host and service
track their changes independently. Otherwise, we'd get alerts when service A
reported "ok" and service B reported "down". There's a shorthand for this:</p>

{% highlight clj %}
(streams
  (changed-state
    (email "ops@startup.io")))
{% endhighlight %}

<p>When you start Riemann, it doesn't know what the previous state was. By
default, <code>changed</code> will forward on the first event it receives. You
can tell <code>changed</code> and <code>changed-state</code> to *assume* an
initial state with the <code>:init</code> option:</p>

{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (email "ops@startup.io")))
{% endhighlight %}

<p>I tend to include this snippet in my riemann configurations so I can keep
track of which services are starting, crashing, and gracefully restarting.</p>

<h3>Measure your app's latency profile</h3>

{% highlight clj %}
; Imagine you wanted to know the time it takes for your app's API requests
; to complete. The API emits events like:
;
; {:service "api req"
;  :metric: 0.240} ; 240 milliseconds
;
; So first, we select only the API requests

(where (service "api req")

       ; Now, we'll calculate the 50th, 95th, and 99th percentile for all
       ; requests in each 5-second interval.

       (percentiles 5 [0.5 0.95 0.99]

                    ; Percentiles will emit events like
                    ; {:service "api req 0.5" :metric 0.12}
                    ; We'll add them to the index, so they can show up
                    ; on our dashboard.

                    index)

       ; What else can we do with API requests? Let's figure out the total
       ; request rate. (rate interval & children) sums up metrics and
       ; divides by time.

       (rate 5)

       ; But this isn't quite right--these event metrics are *times*, so
       ; we're actually calculating the number of seconds spent by the API,
       ; each second. So we *set* the metric of every event to 1, *then*
       ; take the rate:

       (with :metric 1 (rate 5 index))

       ; (with) takes each event and calls (rate) with a *changed*
       ; copy--one where :metric is always 1. Then (rate) adds up all those
       ; 1's over five seconds, and sends that metric to the index.

       ; (with) has a counterpart, by the way: (default). It works exactly
       ; the same, but it only alters the event when the value is nil. Both
       ; with and default accept maps as well:

       (default {:state "ok" :ttl 60} index)
)))
{% endhighlight %}

<h3>Report exceptions</h3>

<p>Where you handle exceptions in your application, you can also submit an
event to Riemann. I usually set the service to the application name, include
the stacktrace as the description, and tag the event with both "exception" and
the classname of the exception.</p>

{% highlight clj %}
(tagged "exception"
  (email "ops@foocorp.com"))

(tagged-all ["exception" "DatabaseError"]
  (email "db@foocorp.com"))
{% endhighlight %}

<p>It's also easy to track the *rate* of exceptions per second, so you can
graph how many unexpected failures occur per day, and determine which services
need the most attention.</p>

{% highlight clj %}
(where (tagged "exception")
  (with :metric 1
    (by :service
      (adjust [:service str " exception rate"]
        (rate 10 index graph)))))
{% endhighlight %}

<h3>Roll up and throttle events</h3>

<p>Sometimes, when things break, they submit a *ton* of events. Maybe you
receive sixty thousand exceptions in five minutes. You need to know that a
problem exists--but don't need to know about *every single failure*. Riemann
has two streams for controlling the rate of events.</p>

<p><a href="api/riemann.streams.html#var-rollup">rollup</a> will allow a few
events to pass through readily. Then it starts to accumulate events, rolling
them up into a list which is submitted at the end of a given time interval.</p>

<p>Let's define a new stream for alerting the operations team, which sends only
five emails per hour (3600 seconds). We'll receive the first four events
immediately--and at the end of the hour, a single email with a summary of all
the rest.</p>

{% highlight clj %}
(def tell-ops (rollup 5 3600 (email "ops@rickenbacker.mil")))

(streams
  (where (state "error") tell-ops)
  (tagged "exception" tell-ops))
{% endhighlight %}

<p>Rollup holds on to every event, which can use a lot of memory. Sometimes
it's OK to drop some events instead of delivering them. That's where <a
  href="api/riemann.streams.html#var-throttle">throttle</a> comes in: it allows
the first five events through, then ignores all the rest for an hour.</p>

{% highlight clj %}
(def tell-ops (throttle 5 3600 (email "ops@rickenbacker.mil")))
{% endhighlight %}

<p>And naturally, you can combine throttle and rollup to preserve *some*
events, but not allow unbounded memory use:</p>

{% highlight clj %}
(def tell-ops
  (throttle 1000 3600
    (rollup 5 3600
      (email "ops@rickenbacker.mil"))))
{% endhighlight %}

<h3>Detect down services</h3>

<p>Each event has a TTL, which states how many seconds the event is valid for
after its given time. When a service crashes catastrophically, it will stop
submitting events and its events in the index will become stale. Periodically,
the index sweeps out events past their lifetime, deletes them from the index,
and streams an event for that host and service with state "expired".</p>

<p>You can control how often the index scans for expired events with
<code>periodically-expire</code>. Here, we check every ten seconds. If you
*don't* want events to expire from the index, you can delete this line from
your config:</p>

{% highlight clj %}
(periodically-expire 10)
{% endhighlight %}

<p>If events have no TTL given, the index assumes their TTL is 60 seconds. You
can provide a default TTL for any incoming events that don't provide one:</p>

{% highlight clj %}
(streams
  (default :ttl 10
    ; your streams here
    ))
{% endhighlight %}

<p>Now, any services that fail to check in every ten seconds will expire
(unless they give a different TTL). Since expired events have a different
state, any (changed :state) streams will detect the transition and can alert
you:</p>

{% highlight clj %}
(streams
  (changed :state {:init "ok"}
    (email "ops@foo.com")))
{% endhighlight %}

<p>You can also explicitly filter expired events:</p>

{% highlight clj %}
(streams
  ; Email any expired event
  (expired (email "ops@foo.com"))

  ; Process only events which are *not* expired
  (where (not (expired? event))
    ...))
{% endhighlight %}

<p>By default, Riemann copies <code>[:host :service]</code> to expired events.
You can control what keys from events are copied onto expired events by
passing <code>:keep-keys</code> to <code>periodically-expire</code>:</p>

{% highlight clj %}
(periodically-expire 10 {:keep-keys [:host :service :tags]})
{% endhighlight %}

<p>With that in place, you can filter expired events on tags. This way, your app
can decide whether an event is worthy of an alert by tagging it:</p>

{% highlight clj %}
(streams
  (expired
    (tagged "notify-me" (email "ops@foo.com"))))
{% endhighlight %}

<h3>Group events in time</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes you want to ask a question about the last few minutes, or of
    groups of 10 consecutive events at a time.</p>

    <ul>
      <li><a href="api/riemann.streams.html#var-moving-time-window">moving-time-window</a> forwards the last n seconds of events</li>
      <li><a href="api/riemann.streams.html#var-moving-event-window">moving-event-window</a> forwards the last n events</li>
      <li><a href="api/riemann.streams.html#var-fixed-time-window">fixed-time-window</a> forwards events from disjoint n-second windows</li>
      <li><a href="api/riemann.streams.html#var-fixed-event-window">fixed-event-window</a> forwards disjoint sequences of n events</li>
    </ul>
  </div>
</div>

<h3>Change units</h3>

<div class="row">
  <div class="sixcol">
    <p>Use the <a href="/api/riemann.streams.html#var-scale">scale</a> stream. For instance, to convert bytes to gigabytes, scale by 1/1024^3.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(scale (/ 1 1024 1024 1024)
  index)
{% endhighlight %}
  </div>
</div>

<h3>Find the host using the most CPU</h3>

<div class="row">
  <div class="sixcol">
    <p>If you're running riemann-health, all hosts will report events like
    <code>{:service "cpu" :host "foo" :metric 0.12}</code>. You want to know
    which host is under the heaviest CPU load. The <code>coalesce</code> stream
    remembers the last events from each host and service, and sends them all as
    a vector to its children. We can map that vector of events to a single
    event--the one with the largest metric--using folds/maximum. Then we just
    set the service and host, since this event pertains to the system as a
    whole.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(coalesce (smap folds/maximum
  (with {:service "Max CPU" :host nil} prn)))
{% endhighlight %}
  </div>
</div>

<h3>Alerting when a certain percentage of events happen</h3>

<p>Sometimes you'll have a service that will fail. You might expect one or two
failures, but if you get over a certain percentage of failures you want to be
notified. In this case you can use a <code>fixed-time-window</code>.</p>

{% highlight clj %}
(streams
  (where (and (service "signin")
              (not (expired? event)))
    ; We want to get alerted about failed sign ins. However we expect that
    ; there will be failures due to incorect passwords etc. So we only want to
    ; get alerted if more than 50% of the signins in a 60 second period are
    ; failures. Failed signings have state "warning".
    ;
    ; fixed-time-window sends a vector of events out every 60 seconds
    (fixed-time-window 60
      ; smap passes those events into a function
      (smap (fn [events]
        ; Given a list of events, we'll find the number which have state
        ; warning, divide by the total number of events, and emit a new event
        ; based on the ratio.
        (let [fraction (/ (count (filter #(= "warning" (:state %)) events))
                          (count events))]
          ; The metric for this event will be the fraction of failed signins,
          ; and the state will depend on how many failures we see.
          {:service "signin failures"
           :metric  fraction
           :state   (condp < fraction
                      0.7 "critical"
                      0.3 "warning"
                          "ok")}))
        ; Now we can use those "signin failures" events to alert on state
        ; transitions:
        (changed-state (email "ops@trioptimum.com"))))))
{% endhighlight %}

<h3 id="arbitrary-functions-as-streams">Arbitrary functions as streams</h3>
<div class="row">
  <div class="sixcol">
    <p>Since streams are just functions which take an event as their sole
    argument, you can do <i>any</i> computation over events that you like. Just
    write a function, either named or anonymous.</p>

    <p>You can run any Clojure code you like here; using Clojure or Java
    libraries on the classpath, writing to the network, logging to disk, using
    existing variables from the config, and so on. It's up to you.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "foo")
  (fn [event]
    ; Log a message
    (info "I got an event:" event)

    ; Then extract some fields and insert them into a DB.
    (save-to-my-database (:description event) (:metric event))))
{% endhighlight clj %}
  </div>
</div>

<h3 id="create-your-own-stream-function">Create your own stream function</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann builtins like <code>rate</code>, <code>percentiles</code>,
    <code>smap</code>, and so on are all functions which take a variable number
    of child streams and returns a function that takes an event and responds to
    that event. You can build your own stream-generating functions too.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Let's create a trivial example.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn hello-stream [& children]
  (fn [e] (let [new-event (assoc e :hello :world)]
    (call-rescue new-event children))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Our stream returns a function that when it receives an event, adds a new
    key-pair via <code>assoc</code> and then uses <code>call-rescue</code>, a
    standard library function, to pass the event on to all the child streams it
    was passed.</p>

    <p>Add this new stream to the list of event streams.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams (hello-stream prn))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now when you pass an event into Riemann you should see the event printed
    out with an added key-value pair of <code>:hello :world</code>.</p>

    <p>Streams all essentially work in this way, if you look at the source code
    of the Streams namespace in <code>streams.clj</code>. You can find a few
    simple examples in the functions <code>match</code>, <code>expired</code>,
    <code>under</code> and <code>over</code> which filter whether the event is
    passed along the event stream.</p>
  </div>
</div>

<h3>Reinject events</h3>

<div class="row">
  <div class="sixcol">
    <p>To reinsert an event back into the current core, use
    <code>riemann.config/reinject</code>. Reinjected events flow through all
    top-level streams, just as if they had just arrived from the network. In
    this example, incoming "initial" events are remapped to "derivative"
    events and reinjected into the streaming system. Each event is printed
    twice, first "initial", then "derivative".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (streams/where (service "derivative")
    #(info "derivative" %))
  (streams/where (service "initial")
    #(info "initial" %)
    (streams/with :service "derivative" reinject)))
{% endhighlight %}
  </div>
</div>

<h3>Query the index from within a stream</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes, you want the behavior of a stream to depend on the current
    state of the index. Say, for instance, that you wanted to use a
    mainentance-mode service to suppress alerting. To enter maintenance mode,
    we'll submit an event to Riemann which has a TTL as long as the maintenance
    window we want. Here's a ten minute window, sent from a Ruby client:</p>
  </div>
  <div class="sixcol last">
{% highlight rb %}
1.9.3p385 :001 > Riemann::Client.new << {service: "maintenance-mode",
                                         host:    nil,
                                         state:   "active",
                                         ttl:     600}
 => nil
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Next, we'll write a function which identifies whether maintenance mode
    is active. We could use <code>riemann.index/lookup</code> to find a
    particular host/service pair, or <code>riemann.index/search</code> for a
    more general query.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn maintenance-mode?
  "Is Riemann currently in maintenance mode?"
  []
  ; Take an expression representing a query for maintenance mode
  (->> '(and (= host nil)
             (= service "maintenance-mode"))
       ; Search the current Riemann core's index for any matching events
       (riemann.index/search (:index @core))
       ; Take the first match
       first
       ; Find its state
       :state
       ; Is it the string "active"?
       (= "active")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we can use that function inside of a where predicate, to pass events
    on only when we're *not* in maintenance mode.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (where (not (maintenance-mode?))
      (email "ops@trioptimum.com"))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Naturally, you could parameterize the maintenance-mode function, perhaps
    taking a host, tag, or service as an argument, and searching for particular
    matching events.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn maintenance-mode [host]
  ; Using (list) to build a query dynamically
  (->> (list 'and (list '= 'host host)
                  '(= service "maintenance-mode"))
       ...))

(where (not (maintenance-mode? host))
  (email "ops@trioptimum.com"))))
{% endhighlight %}
  </div>
</div>

<h2>Working with the dashboard</h2>

<h3>Application specific host grouping</h3>
<p>
It is generally desirable to group all the hosts for a specific service into a
single dashboard view. For example, all the web servers are in single view while
all the database servers are in another view.
</p>

<p>
This is usually not an issue when you are sending custom metrics using Riemann
client. However, there are cases where you are using something that you do not
control how the metrics are being sent. i.e., Riemann-tools.
</p>

<p>
Since Riemann-tools scripts are application agnostic, in order for the
dashboard view to group hosts, we must inject some application specific
information into the tags field. Tags is a collection of arbitrary strings.
In the case of Riemann-tools scripts you can pass in arbitrary strings on the
command line.
</p>

<p>
  <code>riemann-health --host 127.0.0.1 --tag "prod" --tag "webserver"</code>
</p>

<p>In this case, the above health check will include two extra tags "prod" and
"webserver". On the dashboard side, you can create a grid view which contains
the following query: </p>

<p><code>(tagged "prod" and tagged "webserver")</code></p>

<p>The tagged keyword in the query ensures that the given tag is present in the
list of tags for a given event. This query will return only "prod" and
"webservers" hosts.</p>

<h3>Count total number of hosts</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes it is useful to know how many hosts are sending data to
    Riemann.  This is especially useful in cloud environments where nodes are
    constantly scaling up and down. We'll assign every event the same service,
    use <code>coalesce</code> to combine the current set of hosts and services
    into a single map, <code>throttle</code> to cut down on the number of
    updates, and <code>folds/count</code> to count the distinct set of hosts.
    Finally we'll strip the host from that event, since it represents a
    property of the entire system, and index it.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
; All services should be the same
(with :service "distinct hosts"
  ; Combine hosts and services
  (coalesce
    ; Only one update per second.
    (throttle 1 1
      ; Turn lists of events into a single event with the count as its metric
      (smap folds/count
        ; Strip host field
        (with :host nil
          index)))))
{% endhighlight %}
  </div>
</div>

<h2>Integrating with other systems</h2>

<h3>Send email</h3>

<p><code>riemann.email</code> can send single events--or vectors of events--via email:</p>

{% highlight clj %}
(let [email (mailer {:from "riemann@trioptimum.com"})]
  (streams
    (where (state "critical")
      (email "shodan@tauceti.five"))))
{% endhighlight %}

<p>You can use any options for <a href="https://github.com/drewr/postal">Postal</a>:</p>

{% highlight clj %}
(mailer {:from "riemann@trioptimum.com"
         :host "mx1.trioptimum.com"
         :user "foo"
         :pass "bar"})
{% endhighlight %}

<h3>Forward to Graphite</h3>

<p>First, you define a client to graphite, which maintains a connection pool:</p>

{% highlight clj %}
(def graph (graphite {:host "my.graphite.server"}))
{% endhighlight %}

<p>Then, use the client as a stream:</p>

{% highlight clj %}
(streams
  (where (service "thing-to-graph")
    graph))
{% endhighlight %}

<p>Or just graph everything:</p>

{% highlight clj %}
(streams
  graph)
{% endhighlight %}

<h3>Forward to Librato Metrics</h3>

<p>Create a client for librato-metrics with your username and API key:</p>

{% highlight clj %}
(def librato (librato-metrics \"aphyr@aphyr.com\" \"abcd01234...\"))
{% endhighlight %}

<p>Then use it in streams:</p>

{% highlight clj %}
(streams
  (tagged \"latency\" (librato :gauge)))
{% endhighlight %}

<p>You can submit events as annotations too. See the <a href="api/riemann.librato.html#var-librato-metrics">librato-metrics documentation</a>.</p>

<h3>Notify with Pagerduty</h3>

<p>Create a client with your pagerduty service key, then use <code>:trigger</code> and <code>:resolve</code> to open and close issues for a given host and service:</p>

{% highlight clj %}
(let [pd (pagerduty "my-service-key")]
  (streams
    (changed-state
      (where (state "ok")
        (:resolve pd)
        (else (:trigger pd))))))
{% endhighlight %}

<h3>Forward between Riemann servers</h3>

<p>When you have *many* events, you can use multiple Riemann servers to scale
out. You might, for instance, run one Riemann server per datacenter, and
forward only state changes in each service to a master server for a birds-eye
view.</p>

{% highlight clj %}
(streams
  (let [client (tcp-client :host "aggregator")]
    (by [:host :service]
       (changed :state
                (forward client)))))
{% endhighlight %}


<h2>Contributing to Riemann</h2>

<h3>Write a client</h3>

<p>A TCP connection to Riemann is a stream of messages. Each message is a 4
byte network-endian integer *length*, followed by a Protocol Buffer Message of
*length* bytes. See the <a
  href="https://github.com/aphyr/riemann-java-client/blob/master/src/main/proto/riemann/proto.proto">protocol
  buffer definition</a> for the details.</p>

<p>Over UDP, the length header is omitted; just send the protobuf Message
directly. UDP datagrams have a default maximum size of 16384 bytes by
Riemann's default; larger messages should go over TCP. This limit is
configurable in both the client and server; client values *must* be smaller
than the server's.</p>

<p>The server will accept a repeated list of Events, and respond with a
confirmation message with either an acknowledgement or an error. Check the `ok`
boolean in the message; if false, message.error will be a descriptive
string.</p>

<p>Because protocol buffers is strongly typed, the metric of an event is
represented as one of metric_d (floating point 64-bit), metric_f (floating
point 32-bit), or metric_sint64 (64-bit signed integer). Your client should emit
and consume all of these types. For compatibility with older versions of
Riemann, you may *also* emit a metric_f alongside the normal type; newer
versions of Riemann will prefer the higher-resolution types.</p>

<p>Events are uniquely identified by host and service. Both allow null.
Event.time is the time in unix epoch seconds and is optional. The server will
generate a time for each event when received if you do not provide one. I don't
need time resolution finer than 1 second presently, but if you do, my plan is
to add a nanosecond field as well.</p>

<p>You can also query events from the index using a basic query language. Just
submit a Message with your query in message.query.string. Search queries will
return a message with repeated Events matching that expression. A null
expression will return no states. For some example queries, see <a
  href="https://github.com/aphyr/riemann/blob/master/test/riemann/query_test.clj">The
  query test suite</a>.</p>

<p>You might find it useful to read the <a
  href="https://github.com/aphyr/riemann-ruby-client">Ruby client</a> source as
a guide to writing your own client.</p>

<h3>Work with the Riemann source</h3>

<p>I try to keep master as clean and runnable as possible. Riemann has an
exhaustive test suite, which helps ensure code quality. If you plan on changing
the Riemann source, fork it on Github so you'll be able to send pull requests
quickly. If you just want to run the latest version, go ahead and clone the
official repo:</p>

{% highlight sh %}
git clone git://github.com/aphyr/riemann.git
cd riemann
{% endhighlight %}

<p>You'll also need a JVM, and <a
  href="https://github.com/technomancy/leiningen">leiningen 2</a>--the Clojure
build system.</p>

<p>To run the tests suite, try <code>lein test</code>. To start Riemann, run
<code>lein run</code>. Riemann will read the file <code>riemann.config</code>
in the current directory. If you want to run a different config file, try</p>

{% highlight sh %} lein run -- path/to/my/riemann.config {% endhighlight %}

<p>If you want a fat jar, run <code>lein uberjar</code> and copy
target/riemann-{version}-STANDALONE.jar. To build tarball and debian packages,
use <code>lein pkg</code>; .debs and .tar.gz files, plus md5sums, will appear
in <code>target/</code>.

<p>The protocol buffer codec and clojure client live in <a
  href="https://github.com/aphyr/riemann-clojure-client">riemann-clojure-client</a>,
which wraps the java protobuf code and java client in <a
  href="https://github.com/aphyr/riemann-java-client">riemann-java-client</a>.
Both of these are available on clojars and most of the time you can ignore
them. However, if you need to change the protocol or client, you can fork these
projects and make your changes there.</p>

<h3>Building riemann-java-client</h3>

<p>You'll need maven, and the protocol buffers compiler (protoc) version
2.4.1.</p>

<p>When you've made changes to the java client, install it with <code>mvn
  install</code>; then test the clojure client and install it with <code>lein
  install</code>. Finally, you can run riemann itself. You may need to check
that the client versions you're working with match up in the riemann and
riemann-clojure-clientproject.clj files.</p>

<h3>Fix a bug or add a feature</h3>

<p>First, <a href="https://github.com/aphyr/riemann">fork Riemann on
  github</a>. Clone your fork and create a new topic branch for your fix:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout -b fix-some-bug
{% endhighlight %}

<p>Most of Riemann's source lives in <code>src/riemann/</code>. Corresponding
tests live in <code>test/riemann/test/</code>. When you fix a bug or add a
feature, make sure to add new tests that confirm its correctness! You can run
the test suite with</p>

{% highlight sh %}
lein test
{% endhighlight %}

<p>Some tests for integrating with other services require a local sendmail, or
graphite, or credentials for a web service. If you make changes that affect
these systems, you can test them with special selectors like <code>lein test
  :graphite</code> or <code>lein test :email</code>. If you're working with a
particular namespace, like <code>riemann.streams</code>, <code>lein test
  riemann.test.streams</code> runs only the tests for that namespace. Once your
tests pass, commit your changes and push them to github:</p>

{% highlight sh %}
git commit -a
git push origin fix-some-bug
{% endhighlight %}

<p>If you change more than a few lines of whitespace, please make your
formatting changes in a separate commit; it'll be easier for me to read and
understand your changes. Please try to send me only a few commits where
possible; use <code>rebase --interactive</code> to squash your small
changes.</p>

<h3>Help write documentation</h3>

<p>Riemann's web site and documentation are in the gh-pages branch of the
riemann repository. <a href="https://github.com/aphyr/riemann">Fork riemann on
  github</a>, clone your fork, and check out the branch:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout gh-pages
vim howto.html
{% endhighlight %}

<p>Pages are built with Jekyll. To see how your changes will appear on the site,</p>

{% highlight sh %}
sudo apt-get install python-pygments jekyll
cd riemann
jekyll
{% endhighlight %}

<p>... and open _site/howto.html in a web browser. When you're satisfied with
your changes, commit, push, and send me a pull request:</p>

{% highlight sh %}
git commit -am "Added a howto guide for integrating with FooService"
git push
{% endhighlight %}

    </div>
  </div>
</div>
