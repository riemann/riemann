---
title: Riemann - Howto
layout: default
---

<style>
  body {
    background: #ff9000; /* Old browsers */
    background: -moz-radial-gradient(center, ellipse cover,  #ff9000 0%, #d14c00 100%); /* FF3.6+ */
    background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#ff9000), color-stop(100%,#d14c00)); /* Chrome,Safari4+ */
    background: -webkit-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Chrome10+,Safari5.1+ */
    background: -o-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* Opera 12+ */
    background: -ms-radial-gradient(center, ellipse cover,  #ff9000 0%,#d14c00 100%); /* IE10+ */
    background: radial-gradient(ellipse at center,  #ff9000 0%,#d14c00 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ff9000', endColorstr='#d14c00',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */
  }
</style>

<div class="row">
  <h1 class="twelvecol">A <span class="focus">guide</span> to working with Riemann</h1>
</div>

<div class="row">
  <div class="sixcol">
    <p>This is not a comprehensive guide to everything in Riemann, but it can
    get you started and help solve specific problems. Want to add your own
    article to this page? <a href="#help-write-documentation">Send me a pull
      request!</a></p>
  </div>

  <div class="sixcol last">
    <p>Once you know where to look, you can learn more by reading the <a
      href="api">API docs</a> (especially <a
      href="api/riemann.streams.html">riemann.streams</a>), and <a
      href="https://github.com/riemann/riemann/tree/master/src/riemann">the
      source</a>.  I try hard to write readable code. The <a
      href="https://github.com/riemann/riemann/tree/master/test/riemann">test
      suite</a> is also a great place to look for use examples.</p>
  </div>
</div>

</div><!-- container -->
<div class="light">

<div class="container">

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function() {
      $("#toc").tableOfContents(null, {
        startLevel: 2,
        depth: 2,
        topLinks: true
      });
    });
  </script>

  <div class="row">
    <div class="twelvecol">
      <div id="toc">
      </div>
    </div>
  </div>

  <div class="row">
    <div class="twelvecol">

<h2>Running Riemann</h2>

<div class="row">
  <div class="sixcol">
    <h3>Changing the config</h3>
    <p>If you use the Debian or Centos packages, Riemann adds a
    <code>riemann</code> user, stores its configuration in
    <code>/etc/riemann/riemann.config</code>, and logs to
    <code>/var/log/riemann.log</code>. You should always tail the log file when
    working with Riemann; it'll alert you to configuration errors and help you
    debug your streams.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
tail -F /var/log/riemann.log
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In another terminal, use your favorite editor to open
    <code>/etc/riemann/riemann.config</code>. Let's add a logging stream, so we
    can see all events that pass through the streams. <code>#(info %)</code>
    expands into <code>(fn [x] (info x))</code>, which is a function that takes
    an event and logs it at the INFO log level.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  index
  ...
  #(info "received event" %))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we need to reload the config file. Riemann will respond to SIGHUP,
    or you can use the init scripts. You'll see a message about reloading the
    config in the Riemann log. If you make a mistake, like a syntax error,
    Riemann will continue running with the old config and won't apply the new
    one. Instead, it'll log an explanation of the problem, so you can
    investigate and fix it.</p>

    <p>Now that the config has been reloaded, you should see events flowing by
    in the log. Some come from external sources, like riemann-health or your
    own programs. Others are generated by Riemann internally, as a part of its
    internal performance instrumentation. You can insert logging statements
    anywhere in your streams to verify what kind of events are flowing through
    that point.</p>

    <p>Reloading is experimental, and is subject to the normal Clojure rules
    about <code>(def)</code> and <code>(defn)</code>. To avoid confusion, use
    <code>let</code> bindings instead of <code>def</code>; it'll guarantee
    reloads work correctly. If reloads seem broken, you might need to do a
    full restart for your changes to take effect.</p>
  </div>

  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<h3>A minimal configuration</h3>
<div class="row">
  <div class="sixcol">
    <p>We present here a minimal configuration which only prints incoming events to
      standard output. This configuration can prove useful when debugging clients to
      make sure expected events are reaching Riemann.</p>

    <p>This example includes a full configuration, later examples will focus on streams.
      The following actions are performed:

      <ul>
        <li><code>logging/init</code>: Setting-up logging to log to standard output (<code>STDOUT</code>).</li>
        <li><code>tcp-server</code>: Starting a Riemann TCP server on port 5555 (the default).</li>
        <li><code>instrumentation</code>: Disabling internal event production.</li>
      </ul>
    </p>

    <p>Since streams expects a list of functions to call with individual events, we can
       output any input by calling <code>prn</code> on them.
    </p>

  </div>
  <div class="sixcol last">
{% highlight clj %}
(logging/init {:console true})
(tcp-server {})
(instrumentation {:enabled? false})

(streams
 prn)
{% endhighlight %}
  </div>
</div>

<h3>Including functions from multiple files</h3>
<div class="row">
  <div class="sixcol">
    <p>Often your Riemann configuration file will get quite large as you add
    streams and handle more events. Additionally, if you're managing Riemann
    with a configuration management tool like Puppet or Chef then it can be
    complex to template a large configuration file. To help with this Riemann
    also supports including functions via Clojure's namespacing model. These
    can include your own <a href="#create-your-own-stream-function">custom
    stream functions</a>. </p>

		<p>To enable this, the contents of the directory containing the
    <code>riemann.config</code> configuration file are included in the
    <code>CLASSPATH</code>.</p>
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>To use other functions then create a source directory for them. For example,
    to create functions specific to your organization you might create a
    <code>examplecom.etc</code> namespace.</p>
  </div>
 <div class="sixcol last">
 {% highlight sh %}
 sudo mkdir -p /etc/riemann/examplecom/etc
 {% endhighlight %}
 </div>
</div>
<div class="row">
 <div class="sixcol">
   <p>Then create a namespace containing the functions we wish to include in a
   file in this directory, for example <code>email.clj</code>.</p>
 </div>
<div class="sixcol last">
{% highlight clj %}
; Create a new function with ns
(ns examplecom.etc.email
  (:require [riemann.email :refer :all]))

(def email (mailer {:from "reimann@example.com"}))
{% endhighlight %}
</div>
</div>
<div class="row">
 <div class="sixcol">
   <p>We would then require this namespace in our <code>riemann.config</code>.
   With this we could use the <code>email</code> variable inside our Riemann
   configuration.</p>

	 <p>You can read more about Clojure's <a
   href="http://www.braveclojure.com/organization/">namespacing and how it
   works</a>.</p>

   <p>This approach is supported in Riemann 0.2.11 and later.</p>
 </div>
<div class="sixcol last">
{% highlight clj %}
; Require the example.etc.email functions
(require '[examplecom.etc.email :refer :all])
{% endhighlight %}
</div>
</div>

<h3>Putting Riemann into production</h3>
<div class="row">
  <div class="sixcol">
    <p>Riemann has three main parts: clients, the server, and dashboard. By
    default, all listen on the loopback interface. You'll need to configure
    each to listen to an appropriate interface for your environment. On the
    host that runs the Riemann server, open
    <code>/etc/riemann/riemann.config</code>, and change the host that Riemann
    binds to. To listen on all interfaces, use <code>0.0.0.0</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host}))
{% endhighlight %}
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>Now we need to reload Riemann to tell it about our changes.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
sudo service riemann reload
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>To change the address that the dashboard binds to, <a href="https://github.com/riemann/riemann-dash">edit riemann-dash's config.rb</a>.</p>
  </div>
  <div class="sixcol last">
{% highlight rb %}
set :bind, "1.2.3.4"
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-dash only serves some JS code and a small piece of
    configuration; when you open riemann-dash in the browser, it'll open
    connections from your browser to the Riemann server's websocket interface
    to receive events. To connect the dashboard to a remote Riemann server,
    double-click the text box in the top right of the dashboard, and change the
    address from <code>127.0.0.1:5556</code> to your Riemann server's host and
    port. When you hit enter, the browser will initiate a websocket connection
    to that address and begin displaying events. Hit <code>s</code> to save the
    new dash config; the dashboard will connect to that address every time you
    load the page.</p>

    <p>Riemann-dash is not the only dashboard for Riemann; Riemann decouples
    data processing and visualization. Opening the Riemann server from your
    browser *won't* work.</p>

    <p>If the dashboard is unable to connect to the Riemann websocket server,
    you'll see an alert pop up every few seconds. Check that the server is
    running, that the Riemann websocket server is reachable from your browser,
    that you used the correct host and port, and so on.<p>

    <p>If you don't see *anything* on the dash, but it connected successfully,
    you may not have any events to show, or you may not have set up any
    views.</p>
  </div>
</div>

<h3>Using Docker</h3>

<div class="row">
  <div class="sixcol">
    <p>Instead of installing Riemann directly on your system, you can also use
      <a href="https://www.docker.com/">Docker</a> to run it. There is a
      prepackaged Docker image available as <code>riemannio/riemann</code>.</p>
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>With its default configuration, Riemann will index all incoming events
      and print expired events. Make sure to bind the
      <a href="#what-ports-does-riemann-use">neccessary ports</a> to your
      host system, or else you won't be able to send events to Riemann.</p>
    <p>If you expect lots of traffic and don't need segregating of containers,
      you can also skip the Docker network and use the host network by using the
      <code>--net host</code> flag. Note that the default Riemann configuration
      in Docker will listen on <strong>all</strong> network interfaces, so make
      sure to either mount a different configuration (see below) or configure
      your firewall appropriately.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
docker run --rm -p 5555:5555 riemannio/riemann
{% endhighlight %}

{% highlight sh %}
docker run --rm --net host riemannio/riemann
{% endhighlight %}
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>Riemann will, by default, use a configuration file located at
      <code>/etc/riemann.config</code>, which you will most likely override by
      mounting your own configuration into the container.</p>
    <p>For this you can either mount your configuration file at the default
      location or override the default container command
      (<code>/bin/riemann /etc/riemann.config</code>) if for some reason you
      want to change more command line options.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
docker run \
  --rm \
  -p 5555:5555 \
  -v $(realpath riemann.config):/etc/riemann.config \
  riemannio/riemann
{% endhighlight %}

{% highlight sh %}
docker run \
  --rm \
  -p 5555:5555 \
  -v $(realpath myapp.clj):/myapp.clj \
  riemannio/riemann \
  /bin/riemann /myapp.clj
{% endhighlight %}
  </div>
</div>
<div class="row">
  <div class="sixcol">
    <p>To keep things manageable, you can use
      <a href="https://docs.docker.com/compose/">Docker Compose</a> to define
      how the Riemann container should be run.</p>
  </div>
  <div class="sixcol last">
{% highlight yaml %}
version: "3"
services:
  riemann:
    image: riemannio/riemann:latest
    ports:
      - "127.0.0.1:5555:5555"
      - "127.0.0.1:5555:5555/udp"
      - "127.0.0.1:5556:5556"
    volumes:
      - ./riemann.config:/etc/riemann.config
{% endhighlight %}
  </div>
</div>

<h3>Which JVM should I use?</h3>

<div class="row">
  <div class="sixcol">
    <p>Oracle JDK8 is likely to be the fastest option (and supports the full
    range of aggressive tuning options with <code>riemann -a</code>), but we
    test and deploy with JDK 8, from both Oracle and OpenJDK, and JDK 9 from Oracle.
    You're welcome to give other JVMs a shot, though!</p>
  </div>
</div>

<h3>What protocol should I use to talk to Riemann?</h3>

<div class="row">
  <div class="sixcol">
    <p>Use the Riemann TCP protocol. If you have to, and know what you're
    doing, back off to UDP, HTTP, or Graphite.</p>

    <p>Use UDP if you <i>intend</i> to have the OS and network discard data
    automatically, instead of application-level flow control. Don't use UDP
    "for speed"; it's designed to drop data, it will drop data, and you'll
    spend a long time trying to figure out <a
    href="https://github.com/etsy/statsd/issues/245">why your stats are
    wrong</a>. UDP may be appropriate for sampling events where discarding
    large parts of the datastream is OK, but if different nodes drop packets at
    different rates you'll introduce sampling bias. If you don't understand
    what this means, don't use UDP.</p>

    <p>Use HTTP only if a TCP client is unavailable; it introduces significant
    encoding and state machine overhead, takes more bytes on the wire, and
    can't represent the full range of Riemann events.</p>

    <p>Use the Graphite server and other compatibility shims only for interop
    with legacy systems. The graphite protocol can only represent a small
    subset of the Riemann data model; you'll have to do additional work to
    reconstruct meaningful events.</p>
  </div>
</div>

<h3>What ports does Riemann use?</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann runs servers by default on several ports.

      <ul>
        <li>TCP on port 5555.</li>
        <li>TLS on port 5554.</li>
        <li>UDP on port 5555.</li>
        <li>Websockets on port 5556.</li>
        <li>REPL on port 5557.</li>
        <li>OpenTSBD on port 4242</li>
        <li>Graphite on port 2003</li>
      </ul>

    Each server's port can be altered in your configuration.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [host "0.0.0.0"
      iport 1234]
  (tcp-server {:host host :port iport})
  (udp-server {:host host :port iport}))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <h3>Change the log file</h3>

  <div class="sixcol">
    <p>To log to a file, just say</p>

{% highlight clj %}
(logging/init {:file "/path/to/some/riemann.log"})
{% endhighlight %}

    <p>If you'd prefer to only log to stdout, just leave out :file</p>

{% highlight clj %}
(logging/init)
{% endhighlight %}
  </div>
</div>

<h3>Configure Logback</h3>

<div class="row">
  <div class="sixcol">
    <p>Under the hood, Riemann is using Logback.</p>
    <p>To configure Logback, you can provide a configuration file
    via the system property <code>logback.configurationFile</code>.</p>
  <p>For more information, please read the <a
  href="https://logback.qos.ch/manual/configuration.html">Logback documentation</a>.</p>
  </div>

  <div class="sixcol last">
{% highlight sh %}
java -Dlogback.configurationFile=file:///path/to/logback.xml \
-jar riemann-standalone.jar
{% endhighlight %}
  </div>
</div>

<h3>Securing traffic using TLS</h3>

<div class="row">
  <div class="sixcol">
    <p>You can use Riemann across any TCP or UDP VPN, or an SSH tunnel. Riemann
    also supports bidirectional TLS auth as a part of its TCP protocol.</p>

    <p>Before you can use TLS, you need a CA, server key and cert, and a client
    key and cert. Refer to <a
    href="https://github.com/aphyr/less-awful-ssl">less-awful-ssl</a> and <a
    href="https://github.com/OpenVPN/easy-rsa">easy-rsa</a> for more
    details.</p>

    <p>Then, in riemann.config, add a new (or repurpose an existing) TCP server
    for TLS.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(tcp-server {:host "0.0.0.0"
             :port 5554
             :tls? true
             :key "riemann_server.pkcs8"
             :cert "riemann_server.crt"
             :ca-cert "ca.crt"})
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Refer to your client's documentation or source for the client TLS
    options.  In riemann-clojure-client, try something like:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(riemann/tcp-client {:host "1.2.3.4"
                     :port 5554
                     :tls? true
                     :key "riemann_client.pkcs8"
                     :cert "riemann_client.crt"
                     :ca-cert "ca.crt"})
{% endhighlight %}
  </div>
</div>

<div class="row">
<h3>Overriding Riemann functions</h3>

<div class="sixcol">
  <p>Sometimes, something in Riemann doesn't work the way you'd like. When this
  happens, you can redefine any function in Riemann in the config file. Just
  switch to the appropriate namespace, redefine the function, and switch back to
  <code>riemann.config</code>.</p>

  <p>For instance, let's say you wanted to change how emails are formatted. The
  namespace <code>riemann.common</code> has a function called <code>body</code>,
  which accepts a sequence of events and returns a string. We'll override it in
  our config file:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(ns riemann.common)
(defn body [events]
  ; pr-str formats events as a clojure-readable string.
  (pr-str events))
(ns riemann.config)

; And then your servers, streams, etc...
(tcp-server ...)
(streams ...)
{% endhighlight %}
  </div>
</div>

<h3>Fault tolerance</h3>

<div class="row">
  <div class="sixcol">
    <p>Because Riemann performs arbitrary computation over the event stream,
    with side effects, it <i>cannot</i> be distributed safely. You can,
    however, distribute it somewhat less than safely--a technique aligned with
    Riemann's philosophy that "mostly correct information <i>right now</i> is
    more useful, than totally correct information only available once the
    failure is over."</p>

    <p>One obvious distribution strategy is to place two Riemann nodes on the
    same switch and have them share a virtual IP address using, say, Heartbeat
    or Corosync. On resource acquisition, the node allocating the IP should
    issue a gratuitous arp broadcast over that interface advertising the new
    route to the relevant switch(es). Failover in this case looks essentially
    like restarting a Riemann node, which should be relatively painless--most
    Riemann deployments fill in missing state within a few seconds to
    minutes.</p>

    <p>What happens if the nodes are isolated by a network partition and both
    claim the interface? Depends on your network, but the answer is "probably
    not good things". OTOH, there's no good way for *any* consensus algorithm
    in an asynchronous network to make latency-bounded decisions in a safe way.
    FLP rears its ugly head. You're going to lose data in the short term; the
    question is how to emit as much useful, actionable information as possible,
    so you can fix the problem.</p>

    <p>I've got a sketch worked out for a highly-available clustered Riemann
    which tries to negotiate these tradeoffs in a sane way, but it involves
    minimum latency costs, severe throughput costs (I'm estimating three to
    five orders of magnitude slower), disk IO, all kinds of esoteric failure
    modes, and some moderately challenging mathematics. It'd take a long time
    to build and would require some serious educational work on my part.
    There's just no way around it: distributing arbitrary latency-bounded
    computation is hard. You're going to have to reason about consensus. I'm
    really sorry about this. :(</p>
  </div>
</div>

<h3>Sharding</h3>

<div class="row">
  <div class="sixcol">
    <p>Because Riemann performs arbitrary computation, it can't shard your
    workload automatically. You'll need to pick some axes along which to shard,
    perform local aggregation on those nodes, and reduce the results with some
    higher-level Riemann node. The <code>forward</code> stream can help you
    connect nodes to one another, and <code>async-queue!</code> can allow some
    elasticity around latency jitters and downstream node restarts, but the
    actual sharding and discovery mechanics you'll have to build yourself.</p>
  </div>
</div>

<h3>Client backpressure, latency, and queues</h3>

<div class="row">
  <div class="sixcol">
    <p>Event processing in Riemann's model is synchronous (though there's lots
    of asynchronous stuff going on internally). When you send an event to
    Riemann, it flows through every top-level stream, and possibly those
    streams children, and *their* children, and so forth. Once the event has
    flowed through every stream, Riemann sends an acknowledgement back to the
    client. This model enables *backpressure*: clients can use the
    acknowledgements to avoid overwhelming Riemann with more events than it can
    process.</p>

    <p>Riemann keeps track of some internal metrics, exposed as events, for
    stream latency and TCP server latency. Stream latency is how long it took
    for an event to flow through every stream. Server latency is how long it
    took for an event to be picked up by Riemann's TCP server, decoded, handed
    off to the streaming system, processed, and for the acknowledgement to be
    sent back to the client.</p>

    <p>If you wait for an acknowledgement every time you send a message to
    Riemann, each process will behave synchronously. This approach is just fine
    when there are lots of clients sending requests infrequently, where
    "infrequently" means, via Little's Law, that the typical period between
    events is greater than the tcp server latency plus the round-trip network
    time to Riemann itself.</p>

    <p>Sometimes, though, you'll want to send events *faster* than that. You've
    got a few options here.</p>

    <p>If you ignore the acknowledgement messages, you can just shove events at
    Riemann as fast as your runtime will let you. Those events will fill up a
    queue in front of Riemann's streaming system. If that fills up, they'll
    spill over into the Netty queue associated with the channel. If that fills
    up, they'll spill over into the TCP buffer on the Riemann box, and by
    extension, the queues in the network and the sending node. At some point
    TCP backpressure will come into play, but understanding that interaction
    can be complex.</p>

    <p>Doing this kind of infinitely-asynchronous send will manifest as high
    memory consumption on the Riemann node (to store all those queued
    operations), and correspondingly high wait times for events. If events
    arrive *too* far delayed, they may no longer be valid by the time they
    arrive, and you'll start seeing services expire. It's like sending a
    message via a courier who gets stuck in a waiting room and dies en
    route.</p>

    <p>You can detect this (and alert on it) by watching the service called
    "riemann netty event-executor queue size"; if it starts getting above a
    thousand events or so, you're likely overloading Riemann. This queue size
    is directly related to the latency distribution given by "riemann streams
    latency 0.5" and friends, and "riemann streams rate". The higher the
    latency, and the higher the throughput, the larger the queue.</p>

    <p>So: infinite asynchrony is a problem. You want *some* degree of
    asynchrony, especially when Riemann processes faster than the time it takes
    to send events over the network. But too much and you'll crash into finite
    resource limits. We need *backpressure*: bounds on the number of
    outstanding asynchronous requests, or the rate at which we send them.</p>

    <p>One option is simply to spin up more threads and have each send
    synchronously.  Depending on the client's design, you may be able to have
    many threads concurrently sending operations over the same connection.
    Riemann-java-client and riemann-clojure-client, for instance, will
    interleave operations from multiple threads on a single network connection.
    If threads are cheap in your runtime, or you don't need very many (on the
    JVM, more than 10K IO threads is probably a warning sign), this is
    perfectly fine. If you're running in Erlang or Haskell, threads are dirt
    cheap; fire away.</p>

    <p>If threads in your runtime are more expensive, or you don't have them at
    all--say, node.js--you can emulate them using other asynchronous
    constructs.  Riemann-java-client and riemann-clojure-client, for instance,
    have async-send functions that return promises; you can dereference those
    promises to find out whether Riemann acknowledged the message. Deref'ing
    blocks until acknowledgement occurs, or throws an exception if something in
    the network or Riemann went wrong. You can specify a timeout for deref; if
    the timeout is zero, you get a nonblocking check ("did it go through
    yet?"). Fixed timeouts are useful for retries of idempotent operations.
    "Allow this much time, then send again". Same semantics as any other
    asynchronous or stateful construct in Clojure.</p>

    <p>The important thing for *backpressure*, if you're emulating threads
    using asynchronous objects, coroutines, continuations, fibers, callbacks,
    or what-have-you, is that you a.) eventually dereference the results of the
    send, and b.) only allow a fixed number of outstanding asynchronous
    requests.  Riemann-java-client automatically throws (or returns promises
    which throw) when you try to send more than a few thousand concurrent
    messages, forcing you to implement backpressure and flow control logic. You
    can tune this option if you like, but it's there to protect you against
    unbounded resource consumption on either Riemann's side or the client.</p>

    <p>Different clients and different languages will expose these constructs
    in different ways, but you'll find the same core ideas of limited
    asynchrony, queuing, and backpressure in every networked system.</p>
  </div>
</div>

<h2>Debugging</h2>

<h3>Printing events to stdout or the log</h3>

<div class="row">
  <div class="sixcol">
    <p>Streams are just functions, so you can use any function that prints an
    event to stdout to see which events pass through a particular stream.
    <code>prn</code> prints an object to stdout, so adding <code>prn</code> to
    any stream prints the events at that stream to the console.</p>

    <p>If you're running Riemann as a daemon, it probably won't have a stdout
    to print to. To write to the logfile (which is *also*, by default, printed
    to stdout), use <code>#(info %)</code>, which is a shorthand for the
    anonymous function <code>(fn [x] (info x))</code>. Note that
    <code>info</code> logs events a little differently than <code>prn</code>,
    but you can use <code>pr-str</code> to recover the clojure representation
    if desired.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (service "bar")
    ; Print event to stdout
    prn

    ; Print :foo, then the event
    #(prn :foo %)

    ; Log event to the logfile and stdout
    #(info %)

    ; Log event using the same representation as prn
    #(info (pr-str %))

    ; Log some specific fields
    #(info (:service %) (:metric %))
{% endhighlight %}
  </div>
</div>

<h3>Troubleshooting missing events</h3>

<div class="row">
  <div class="sixcol">
    <p>First, determine whether the events you're looking for are actually
    making it into Riemann. This will help localize the problem to the
    <i>network</i> or the <i>streams</i>. Add a new top-level stream which
    simply logs all inbound events. Use a <code>(where)</code> filter around
    that logging stream to cut down on noise.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  #(info %))
{% endhighlight %}

{% highlight clj %}
(streams
  (where (service "some thing you're looking for")
    #(info %)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If you don't see the events you're looking for in the logs, they must
    be dropped <i>before</i> arriving at the streaming system. Check:</p>

    <ul>
      <li>Riemann clients are sending to the correct Riemann host and
      port.</li> <li>Riemann is listening to that host and port. Double-check
      the config (e.g. <code>(tcp-server)</code> options), that the appropriate
      server startup message appears in the Riemann logs, and that and
      <code>netstat -lntp | grep riemann</code> shows the port bound.</li>
      <li>The network can relay packets from the client machine to the Riemann
      server. Use <code>telnet some.host 5555</code> or <code>nmap -sT
        some.host -P 5555</code>.</li>
      <li>Your packets are making it from the client to the server. UDP
      messages can be dropped, delayed, duplicated, or re-ordered at any time
      by the network, or discarded if the receiving node's receive buffer is
      too full. Try using TCP.</li>
    </ul>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If your messages <i>are</i> arriving in the streaming system, but aren't
    making it to the index or other output streams, gradually slide the
    <code>#(info %)</code> stream downstream towards the exit point, to verify
    at which point in the chain the events are not what you expect.</p>

    <p>If you're indexing events, but they don't appear in queries, they may
    have expired from the index. Try <code>(expired #(warn "expired" %))</code>
    to warn about expired events. They may be expiring because their TTL is
    shorter than the interval between events. They may also expire because the
    Riemann clock is in the future relative to the originating event, due to
    clock skew or network/processing latency.</p>

    <p>Check the internal instrumentation for the Riemann queue depth and core
    latencies; if the queue is more than a handful of events deep, or stream
    latencies are on the order of the relevant event TTLs, you might need to
    reduce the load on the Riemann server or investigate downstream services
    that might be slow.</p>

    <p>Check clock skew between nodes using <code>watch date</code> or similar.
    Make sure your clocks are in UTC, <i>not</i> local time. Never local time.
    <i>Especially</i> never Daylight Savings Time. You can use Riemann's
    <code>clock-skew</code> stream to measure clock skew as seen by the Riemann
    node as well.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  #(info %) ; First, measure here
  (where (service #"^riak .+")
    #(info %) ; Then move the info stream here to check the filter
    (by :service
      (coalesce
        #(info %) ; Third, check the coalesced vector of events
        (smap folds/maximum
          #(info %) ; Fourth, probe here to check the maximum calculation
          (with :host nil
            #(info %) ; Finally, check exactly what events are being applied
                      ; to the index.
            index))))))
{% endhighlight %}
  </div>
</div>

<h3>Writing tests</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann has integrated support for building fast, repeatable tests into
    your config itself, including virtualized time and scheduler side effects
    and suppressing unwanted IO during test runs.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In your streams, use <code>riemann.test/tap</code> to declare named
    points where you'd like to observe events. For instance, we might want to
    track any events flowing into the index, so we'd surround it with a tap and
    call that tap <code>:index</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (default :ttl 3 (tap :index (index)))]
  (streams
    (expired #(prn "Expired" %))
      (where (not (service #"^riemann "))
        index)))
{% endhighlight %}

  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Then, we can inject events into the config's streams to see what
    happens. Define tests in any config file using <code>tests</code> and
    <code>deftest</code>.</p>

    <p><code>(inject! events)</code> returns a map of tap names to a vector of
    the events that arrived at that tap. Time is always reset to zero at the
    beginning of each test, and is automatically advanced to each event time
    just prior to event arrival. You may manually advance the clock using
    <code>riemann.time.controlled/advance!</code>. Scheduled operations
    like rate, rollup, etc will take effect atomically as the virtual clock
    advances.</p>

    <p>You can also inject events into specific streams using <code>(inject! [stream] events)</code>.

    <p>Under the hood, <code>tests</code> expands to a new ns declaration based
    on the current namespace--if the current namespace is <code>foo</code>,
    tests take place in <code>foo-test</code>. <code>tests</code> automatically
    refers clojure.test's <code>is</code> and <code>are</code>, plus
    riemann.test's version of <code>deftest</code> and <code>inject!</code> for
    inserting events into the config's streams.</p>

    <p>You can define regular clojure tests too; no need to call <code>inject</code>.
    Every namespace ending in <code>-test</code> is eligible for testing.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(tests
  (deftest index-test
    (is (= {:index [{:service "test"
                     :time    1
                     :ttl     3}]}
           (inject! [{:service "test"
                      :time    1}])
           ))))
{% endhighlight %}

{% highlight clj %}
(def foo-stream
  (where (service "foo")
    (tap :foo)))

(tests
  (deftest foo-test
    ;; inject in foo-stream only
    (let [result (inject! [riemann.config/foo-stream]
                   [{:host "localhost"
                     :service "foo"
                     :metric 10}])]
      (is (= [{:host "localhost"
               :service "foo"
               :metric 10}]
              (:foo result))))))
{% endhighlight %}

{% highlight sh %}
$ riemann test riemann.config
loading bin

Testing riemann.config-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Some streams may have *side effects*, like sending events over the
    network or emitting emails. You can suppress those side effects by wrapping
    them in a <code>test/io</code> stream, which forwards events to its
    children normally in production, but ignores them in test mode.</p>

    <p><code>io</code> suppresses events, which means that <code>(io (tap
    :foo))</code> will never see anything. Always place taps *outside*
  <code>io</code> expressions.</p>

    <p>Note that <code>tap</code> and <code>io</code> are eliminated at
    compile-time during production mode, so there's zero performance penalty;
    won't count against your Hotspot inlining budget, etc.</p>

    <p>From Riemann 0.3.0, the test framework runs a core. Functions
      requiring a core like <code>riemann.config/reinject</code>, indexing
      events, index querying and expiry will work. The index is cleaned
      at the beginning of each <code>deftest</code>.</p>

    <p>Before Riemann 0.3.0, the test framework didn't actually
      run a core, so functions that require one, (like
      <code>riemann.config/reinject</code>), didn't work from within the test
      framework.</p>
    </p>

  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (rate 5
    (io (email "foo@bar.com"))))
{% endhighlight %}
  </div>
</div>

<h3>Connecting to the REPL</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann has an nREPL server built in. You can enable this in your config
    with:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(repl-server {:host "127.0.0.1"})
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can then use Leiningen 2 to connect to it.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
git clone git://github.com/riemann/riemann.git
cd riemann
lein repl :connect 127.0.0.1:5557
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>you can reload the config by sending riemann a sighup, but you can also
    do it from the repl.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
user=> (riemann.bin/reload!)
{% endhighlight %}
  </div>
</div>


<h2>Instrumenting your systems</h2>

<h3>Measure Riemann itself</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann comes with instrumentation built-in, which is sampled
    periodically and injected into the event stream. You can query the
    dashboard for <code>service =~ "riemann %"</code> to see Riemann's internal
    metrics. All latencies are in milliseconds.</p>

    <p><code>riemann streams</code> refers to the stream processor: its
    throughput measures the number of events being passed to <code>(streams
      ...)</code> per second, and its latencies indicate the time it takes to
    process a single event through the streaming system.</p>

    <p>The TCP, UDP, and Websockets servers instrument their throughput and
    latency where possible. TCP latency measures the time from initial message
    deframing to Netty write of the corresponding response. For instance,
    <code>riemann server tcp 1.2.3.4:5555 in latency 0.95</code> measures the
    95th percentile time, in milliseconds, for the TCP server on port 5555 to
    parse, queue, process, and dispatch a response for a message.  The rate for
    servers measures *message* rate, not *event* rate.</p>

    <p>The main queue connecting Netty IO threads to the parsing/execution
    threadpool is measured by <code>riemann netty event-executor queue
    size</code>, and is a critical measure of whether the streaming system is
  overloaded relative to inbound request load.</p>

    <p>To disable instrumentation, or control how often events are sampled, see
    <a
      href="http://riemann.io/api/riemann.config.html#var-instrumentation">riemann.config/instrumentation</a>.</p>
  </div>
</div>

<h3>Measure CPU, memory, and disk use</h3>

<div class="row">
  <div class="sixcol">
    <p><a href="https://github.com/riemann/riemann-tools">Riemann-tools</a>
    includes a program called riemann-health, which measures the local host's
    cpu, memory, and disk use. You can install it from rubygems.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
gem install riemann-tools
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>... and run riemann-health with the address of your riemann server like
    so:</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
riemann-health --host 1.2.3.4
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann-health reports utilization <i>fractions</i> by default, ranging
    from zero to one. Load average is divided by the number of cores, and disk
    use by capacity. You can adjust the polling interval, what percentage of
    CPU usage is considered critical, and more. <code>riemann-health
    --help</code> will tell you more.</p>
  </div>
</div>


<h3>Handle exceptions</h3>

<div class="row">
  <div class="sixcol">
    <p>Streams can produce exceptions. A special event containing the exception details will be sent to the first child of <code>exception-stream</code> if an exception occurs on other child streams.</p>
  </div>
  <div class="sixcol last">
{% highlight clojure %}
(exception-stream (email "polito@vonbraun.com")
                  (async-queue!
                   :graphite
                   {:core-pool-size 128}
                   graph))
{% endhighlight %}
  </div>
</div>

<h3>Monitor Riak</h3>

<div class="row">
  <div class="sixcol">
    <p><a href="https://github.com/riemann/riemann-tools">Riemann-tools</a>
    includes riemann-riak, which uses Riak's HTTP stats interface, some
    filesystem checks, and optionally, some erlang RPC requests to measure
    Riak's get and put latencies, request throughput, ring status, and disk
    use. Run riemann-riak on each Riak node.</p>

    <p>Riemann-riak comes with defaults for the Riak .deb packages shipped by
    Basho, but it's tunable for other configurations. See <code>riemann-riak
    --help</code> for more options.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
gem install riemann-tools
riemann-riak --host 1.2.3.4
{% endhighlight %}
  </div>
</div>

<h3>Custom event attributes</h3>

<div class="row">
  <div class="sixcol">
    <p>You can include arbitrary additional fields in Riemann
    events. These are not a replacement for service, host, and time: the
    composite primary key of a logical "thing" in the Riemann universe, but
    they *do* let you more easily aggregate and filter events, or carry richer
    contextual information associated with a single message.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In most clients you can simply pass an extra key and value in the event
    map. In strongly-typed clients like riemann-java-client, special methods
    like EventDSL.attribute(key, value) are present.</p>
  </div>

  <div class="sixcol last">
{% highlight rb %}
client << {service: "thumbnailer rate",
           metric:  5.0,
           build:   "7543"}
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Custom attributes are always encoded as strings in Protocol Buffers
    (pull request welcome!), but you can replace them with parsed variants in
    your streams using smap, adjust, and friends.</p>

    <p>In the Riemann server, custom attributes work just like normal
    attributes on events--they're just a bit slower, owing to the hashmap
    lookup. Just like normal fields, you can use get, assoc, dissoc, update,
    and all the other Clojure functions over maps. Custom attributes do *not*
    have shorthand syntax in <code>(where)</code> (to prevent arbitrary symbol
    capture), but are accessible through <code>(:my-field event)</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "thumbnailer rate")
  ; Convert build numbers from strings to longs
  (adjust [:build #(Long. %)]
    ; Compute a throughput for each specific build
    (by :build
      (smap #(assoc % :service (str (:service %) " build " (:build %)))
        (rate 5 index)))

    ; Or maybe an old version reported numbers that were 2x larger than they
    ; should have been
    (where (< (:build event) 1055)
      (scale 1/2 index)
      (else index))))
{% endhighlight %}
  </div>
</div>

</div>

<h2>Working with streams</h2>

<h3>Example configs</h3>

<div class="row">
  <div class="sixcol">
    <p>The Guardian has published <a
      href="https://github.com/guardian/riemann-config/blob/master/main.clj">their
    Riemann config files</a>, which may be a useful guide to advanced use.</p>
  </div>
</div>

<h3>Split streams</h3>

<div class="row">
  <div class="sixcol">
    <p>Splitting streams is the default in Riemann. Almost all streams, unless
    otherwise documented, take any number of child streams as their final
    arguments, and forward the same events on to all of them.  Because Riemann
    uses Clojure's immutable data structures, you don't have to worry about
    locking or mutation. Streams "change" events by sending altered,
    shared-structure *copies* of events downstream. For instance, this where
    expression sends matching events to <i>two</i> child streams; one of which
    indexes a copy of the event with service "foo", and the other with service
    "bar".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (host "db04")
  (with :service "foo" index)
  (with :service "bar" index))
{% endhighlight %}
  </div>
</div>

<h3>Combine streams</h3>

<div class="row">
  <div class="sixcol">
    <p>Sending events from two places to the same stream is simple: just bind
    the stream to a variable. In Clojure, <code>(let [x 1 y 2] ...)</code>
    assigns <code>x</code> to <code>1</code> and <code>y</code> to
    <code>2</code> everywhere inside the <code>let</code> expression. Since
    streams are values, you can bind them to variables too. In this example, we
    create a single rate stream and send events to it along multiple paths.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
; Create a stream for the total rate, and name it `aggregate`
(let [aggregate (rate 5 (with :service "req rate" index))]
  ; Return a stream which splits up events based on their service
  (splitp = service
    ; HTTP requests pass straight to the aggregate stream
    "http req rate" aggregate
    ; But we'll double the metrics for 0mq requests
    "0mq req rate"  (scale 2 aggregate)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Even easier: use the <code>pipe</code> stream, which compiles to the
    same code as the <code>let</code> expression above:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
; Within the pipe expression, - marks where events flow to the next stage
(pipe -
  ; The first stage is to split up events by their service
  (splitp = service
    ; HTTP requests pass straight through
    "http req rate" -
    ; But we'll double the metrics for 0mq requests
    "0mq req rate" (scale 2 -))
  ; The second stage is to compute a rate and index it.
  (rate 5 (with :service "req rate" index)))
{% endhighlight %}
  </div>
</div>

<h3>Distinct streams for each host, service, etc.</h3>

<div class="row">
  <div class="sixcol">
    <p>Often, you want to run *many copies* of a particular stream; say,
    computing a rate for each service separately, or each [host, service] pair.
    Use <code>by</code> to bifurcate a stream into distinct copies based on a
    function or vector of functions of that event. For instance, to sum up disk
    use across hosts, but retaining a distinct sum for each service, you could
    write:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(by :service
  (coalesce
    (smap folds/sum
      (with :host nil
        index))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Or to compute a rate for each distinct host and service:
  </div>
  <div class="sixcol last">
{% highlight clj %}
(by [:host :service]
  (rate 5 index))
{% endhighlight %}
  </div>
</div>

<h3>Filter events</h3>

<div class="row">
  <div class="sixcol">
    <p>Often, we want to do some operation only on a subset of events flowing
    through a stream. For instance, we might only want to email events which
    have the state "error". The basic filtering streams are <a
    href="api/riemann.streams.html#var-where">where</a>, her less magical
    sister <a href="api/riemann.streams.html#var-where*">where*</a>, <a
      href="api/riemann.streams.html#var-match">match</a>, <a
      href="api/riemann.streams.html#var-tagged-all">tagged-all</a> and <a
      href="api/riemann.streams.html#var-tagged-any">tagged-any</a>, and <a
      href="api/riemann.streams.html#var-expired">expired</a>. Most of the
    time, you'll use <code>where</code>.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where takes a <i>predicate</i>, which is a special expression for
    matching events. After the predicate, <code>where</code> takes any number
    of child streams, each of which will receive events which the predicate
    matched. For example, we could email only events which have state
    "error".</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (state "error")
    ; Only events which have the state "error" are passed on to the email
    ; stream:
    (email "delacroix@vonbraun.com")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>The <code>where</code> stream provides some syntactic sugar to allow you
    to access your event fields. In a <code>where</code> stream you can refer to
    "standard" fields like <code>host</code>, <code>service</code>,
    <code>description</code>, <code>metric</code>, and <code>ttl</code> by name.
    If you need to refer to another field you need to reference the full field name,
    <code>(:field_name event)</code>.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (= (:type event) "evolution")
    ; Only events which have a type of "evolution" are passed on to the email
    ; stream:
    (email "delacroix@vonbraun.com")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where expressions can match particular values of a field; like passing
    on events which occur only on the Von Braun:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (host "von braun") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Regular expressions (in Clojure, strings like <code>#"foo .+"</code>) can be used to match fields as well.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (description #"an+elids") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can filter for the presence of a given tag.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (tagged "mutant") ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>There are also streams specifically for selecting events which have
    some, or all, of a set of tags. Tagged is shorthand for tagged-all.</p>

  </div>
  <div class="sixcol last">
{% highlight clj %}
(tagged-any ["cat" "dog"] (with :service "animals/sec" (rate 1 index)))
(tagged-all ["ops" "ddos"] (email "ops@githug.com"))

(tagged "page" page-ops)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Numeric functions work like you'd expect:</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(where (>= (* metric 1000) 2.5))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Which makes range queries easy:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (< 5 metric 10))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Predicates can use any function or macro, including boolean operators.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (not (or (tagged "www")
                (and (state "ok") (nil? metric)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You can also define and use arbitrary functions in your predicates.
    (where) binds the variable <code>event</code> to the event being
    considered.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn global? [event] (nil? (:host event)))
(where (global? event))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Higher-order functions work like you'd expect, so you can happily map,
    fold, filter, etc inside a where predicate too. For instance, we can match
    any of several regular expressions:</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (some (fn [r] (re-find r service)) [#"cassandra disk .+"
                                           #"cassandra net .+"
                                           #"cassandra latency \d+"])
  ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Where streams forward an event to their children when the predicate
    matches.  When the predicate *doesn't* match, where will forward events to
    any children in an <code>(else)</code> block.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (or (state "ok") (state "warning"))
  index
  (else
    (email "ops@foo.com")))
{% endhighlight %}
  </div>
</div>

<h3>Set thresholds</h3>

<p>You can use (where) to alert you when a metric goes out of bounds. Where the
metric falls between zero and five, inclusive, index it with state "ok".
Otherwise, index it with "warning":</p>

{% highlight clj %}
(streams
  (where (<= 0 metric 5)
    (with :state "ok" index)
    (else
      (with :state "warning" index))))
{% endhighlight %}

<h3>Detect state transitions</h3>

<p>The <a href="api/riemann.streams.html#var-changed">changed</a> stream
forwards on events when some fields of that event change. For instance, you
can send an email whenever the state changes:</p>

{% highlight clj %}
(streams
  (by [:host :service]
    (changed :state
      (email "ops@startup.io"))))
{% endhighlight %}

<p>Note that we use <code>(by)</code> so that each distinct host and service
track their changes independently. Otherwise, we'd get alerts when service A
reported "ok" and service B reported "down". There's a shorthand for this:</p>

{% highlight clj %}
(streams
  (changed-state
    (email "ops@startup.io")))
{% endhighlight %}

<p>When you start Riemann, it doesn't know what the previous state was. By
default, <code>changed</code> will forward on the first event it receives. You
can tell <code>changed</code> and <a href="http://riemann.io/api/riemann.streams.html#var-changed-state">
<code>changed-state</code></a> to *assume* an initial state with the
<code>:init</code> option:</p>

{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (email "ops@startup.io")))
{% endhighlight %}

<p>I tend to include this snippet in my riemann configurations so I can keep
track of which services are starting, crashing, and gracefully restarting.</p>

<h3>Measure your app's latency profile</h3>

{% highlight clj %}
; Imagine you wanted to know the time it takes for your app's API requests
; to complete. The API emits events like:
;
; {:service "api req"
;  :metric: 0.240} ; 240 milliseconds
;
; So first, we select only the API requests

(where (service "api req")

       ; Now, we'll calculate the 50th, 95th, and 99th percentile for all
       ; requests in each 5-second interval.

       (percentiles 5 [0.5 0.95 0.99]

                    ; Percentiles will emit events like
                    ; {:service "api req 0.5" :metric 0.12}
                    ; We'll add them to the index, so they can show up
                    ; on our dashboard.

                    index)

       ; What else can we do with API requests? Let's figure out the total
       ; request rate. (rate interval & children) sums up metrics and
       ; divides by time.

       (rate 5)

       ; But this isn't quite right--these event metrics are *times*, so
       ; we're actually calculating the number of seconds spent by the API,
       ; each second. So we *set* the metric of every event to 1, *then*
       ; take the rate:

       (with :metric 1 (rate 5 index))

       ; (with) takes each event and calls (rate) with a *changed*
       ; copy--one where :metric is always 1. Then (rate) adds up all those
       ; 1's over five seconds, and sends that metric to the index.

       ; (with) has a counterpart, by the way: (default). It works exactly
       ; the same, but it only alters the event when the value is nil. Both
       ; with and default accept maps as well:

       (default {:state "ok" :ttl 60} index)
)))
{% endhighlight %}

<h3>Report exceptions</h3>

<p>Where you handle exceptions in your application, you can also submit an
event to Riemann. I usually set the service to the application name, include
the stacktrace as the description, and tag the event with both "exception" and
the classname of the exception.</p>

{% highlight clj %}
(tagged "exception"
  (email "ops@foocorp.com"))

(tagged-all ["exception" "DatabaseError"]
  (email "db@foocorp.com"))
{% endhighlight %}

<p>It's also easy to track the *rate* of exceptions per second, so you can
graph how many unexpected failures occur per day, and determine which services
need the most attention.</p>

{% highlight clj %}
(where (tagged "exception")
  (with :metric 1
    (by :service
      (adjust [:service str " exception rate"]
        (rate 10 index graph)))))
{% endhighlight %}

<h3>Roll up and throttle events</h3>

<p>Sometimes, when things break, they submit a *ton* of events. Maybe you
receive sixty thousand exceptions in five minutes. You need to know that a
problem exists--but don't need to know about *every single failure*. Riemann
has two streams for controlling the rate of events.</p>

<p><a href="api/riemann.streams.html#var-rollup">rollup</a> will allow a few
events to pass through readily. Then it starts to accumulate events, rolling
them up into a list which is submitted at the end of a given time interval.</p>

<p>Let's define a new stream for alerting the operations team, which sends only
five emails per hour (3600 seconds). We'll receive the first four events
immediately--and at the end of the hour, a single email with a summary of all
the rest.</p>

{% highlight clj %}
(def tell-ops (rollup 5 3600 (email "ops@rickenbacker.mil")))

(streams
  (where (state "error") tell-ops)
  (tagged "exception" tell-ops))
{% endhighlight %}

<p>Rollup holds on to every event, which can use a lot of memory. Sometimes
it's OK to drop some events instead of delivering them. That's where <a
  href="api/riemann.streams.html#var-throttle">throttle</a> comes in: it allows
the first five events through, then ignores all the rest for an hour.</p>

{% highlight clj %}
(def tell-ops (throttle 5 3600 (email "ops@rickenbacker.mil")))
{% endhighlight %}

<p>And naturally, you can combine throttle and rollup to preserve *some*
events, but not allow unbounded memory use:</p>

{% highlight clj %}
(def tell-ops
  (throttle 1000 3600
    (rollup 5 3600
      (email "ops@rickenbacker.mil"))))
{% endhighlight %}

<h3>Detect down services</h3>

<p>Each event has a TTL, which states how many seconds the event is valid for
after its given time. When a service crashes catastrophically, it will stop
submitting events and its events in the index will become stale. Periodically,
the index sweeps out events past their lifetime, deletes them from the index,
and streams an event for that host and service with state "expired".</p>

<p>You can control how often the index scans for expired events with
<code>periodically-expire</code>. Here, we check every ten seconds. If you
*don't* want events to expire from the index, you can delete this line from
your config:</p>

{% highlight clj %}
(periodically-expire 10)
{% endhighlight %}

<p>If events have no TTL given, the index assumes their TTL is 60 seconds. You
can provide a default TTL for any incoming events that don't provide one:</p>

{% highlight clj %}
(streams
  (default :ttl 10
    ; your streams here
    ))
{% endhighlight %}

<p>Now, any services that fail to check in every ten seconds will expire
(unless they give a different TTL). Since expired events have a different
state, any <a href="http://riemann.io/api/riemann.streams.html#var-changed-state">
(changed-state)</a> streams will detect the transition and can alert you:</p>

{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (email "ops@foo.com")))
{% endhighlight %}

<p>You can also explicitly filter expired events:</p>

{% highlight clj %}
(streams
  ; Email any expired event
  (expired (email "ops@foo.com"))

  ; Process only events which are *not* expired
  (not-expired
    ...)

  ; You can also call the expired? function in a where clause
  (where (not (expired? event))
    ...))
{% endhighlight %}

<p>By default, Riemann copies <code>[:host :service]</code> to expired events.
You can control what keys from events are copied onto expired events by
passing <code>:keep-keys</code> to <code>periodically-expire</code>:</p>

{% highlight clj %}
(periodically-expire 10 {:keep-keys [:host :service :tags]})
{% endhighlight %}

<p>With that in place, you can filter expired events on tags. This way, your app
can decide whether an event is worthy of an alert by tagging it:</p>

{% highlight clj %}
(streams
  (expired
    (tagged "notify-me" (email "ops@foo.com"))))
{% endhighlight %}

<p>You can add a new tag, or a set of tags, to events using the <code>tag</code> stream:</p>

{% highlight clj %}
(streams
  (tag "foo"
    #(info %))
  (tag ["foo" "bar"]
    #(info %)))
{% endhighlight %}

<p>If you're worried about spikes or flapping you can make use of the <a
  href="http://riemann.io/api/riemann.streams.html#var-stable">stable</a>
variable. The <code>stable</code> variable detects stable streams of events
over time. It takes a time period and event function as input and only passes
on events that remain the same for the specified time period.</p>

{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (stable 60 :state
      (email "ops@foo.com"))))
{% endhighlight %}

<h3>Group events in time</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes you want to ask a question about the last few minutes, or of
    groups of 10 consecutive events at a time.</p>

    <ul>
      <li><a href="api/riemann.streams.html#var-moving-time-window">moving-time-window</a> forwards the last n seconds of events</li>
      <li><a href="api/riemann.streams.html#var-moving-event-window">moving-event-window</a> forwards the last n events</li>
      <li><a href="api/riemann.streams.html#var-fixed-time-window">fixed-time-window</a> forwards events from disjoint n-second windows</li>
      <li><a href="api/riemann.streams.html#var-fixed-event-window">fixed-event-window</a> forwards disjoint sequences of n events</li>
    </ul>
  </div>
</div>

<h3>Combine events from different hosts and services</h3>

<div class="row">
  <div class="sixcol">
    <p>Events arrive <i>independently</i> in Riemann, but each describes the
    state of a service on some host over some window of time. Often, you
    want to know how two services <i>relate</i> to one another right now.
    Riemann provides two streams for this type of aggregation: coalesce and
    project.</p>

    <p>Use <a href="api/riemann.streams.html#var-project">project</a> when you
    want to combine a fixed number of events, identified by arbitrary
    predicates. For instance, you might want to know the ratio of <i>used</i>
    gigabytes to <i>total</i> disk capacity, or the difference between
    <i>enqueues</i> and <i>dequeues</i> in a queue.</p>

    <p>Use <a href="api/riemann.streams.html#var-coalesce">coalesce</a> to get
    snapshot of the most recent event from <i>every</i> host and service that
    passes through that coalesce stream. Coalesce helps answer questions like
    "what fraction of my API servers are running the most recent version", or
    "what's the median queue depth across all queues in a given broker?"</p>
  </div>
</div>

<h3>Apply a regular expression to a field</h3>

<div class="row">
  <div class="sixcol">
    <p>You can test whether a field matches a regular expression by simply
    passing a regex to <code>where</code>. Clojure regular expressions look
    like <code>#"..."</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service #"api req latency [\d\.]+")
  ...)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Or you can transform a string using a regular expression and capture
    groups (also called "backreferences") using
    <code>clojure.string/replace</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(require '[clojure.string :as str])

(streams
  ; Replace services like "legacy <anything>" with "new <anything>". Passes
  ; through services that don't match the regular expression, unchanged.
  (adjust [:service str/replace #"^legacy (\w+)$"]
    ...))
{% endhighlight %}
  </div>
</div>

<h3>Change units</h3>

<div class="row">
  <div class="sixcol">
    <p>Use the <a href="/api/riemann.streams.html#var-scale">scale</a> stream. For instance, to convert bytes to gigabytes, scale by 1/1024^3.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(scale (/ 1 1024 1024 1024)
  index)
{% endhighlight %}
  </div>
</div>

<h3>Find the host using the most CPU</h3>

<div class="row">
  <div class="sixcol">
    <p>If you're running riemann-health, all hosts will report events like
    <code>{:service "cpu" :host "foo" :metric 0.12}</code>. You want to know
    which host is under the heaviest CPU load. The <code>coalesce</code> stream
    remembers the last events from each host and service, and sends them all as
    a vector to its children. We can map that vector of events to a single
    event--the one with the largest metric--using folds/maximum. Then we just
    set the service and host, since this event pertains to the system as a
    whole.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(coalesce (smap folds/maximum
  (with {:service "Max CPU" :host nil} prn)))
{% endhighlight %}
  </div>
</div>

<h3>Count total number of hosts</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes it is useful to know how many hosts are sending data to
    Riemann.  This is especially useful in cloud environments where nodes are
    constantly scaling up and down. We'll assign every event the same service,
    use <code>coalesce</code> to combine the current set of hosts and services
    into a single map, <code>throttle</code> to cut down on the number of
    updates, and <code>folds/count</code> to count the distinct set of hosts.
    Finally we'll strip the host from that event, since it represents a
    property of the entire system, and index it.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
; All services should be the same
(with :service "distinct hosts"
  ; Combine hosts and services
  (coalesce
    ; Turn lists of events into a single event with the count as its metric
    (smap folds/count
      ; Strip host field
      (with :host nil
        index))))
{% endhighlight %}
  </div>
</div>

<h3>Alerting when a certain percentage of events happen</h3>

<div class="row">
  <div class="sixcol">
   <p>Sometimes you'll have a service that will fail. You might expect one or
   two failures, but if you get over a certain percentage of failures you want
   to be notified. In this case you can use a
   <code>fixed-time-window</code>.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  (where (and (service "signin")
              (not (expired? event)))
    ; We want to get alerted about failed sign ins. However we expect that
    ; there will be failures due to incorect passwords etc. So we only want to
    ; get alerted if more than 50% of the signins in a 60 second period are
    ; failures. Failed signings have state "warning".
    ;
    ; fixed-time-window sends a vector of events out every 60 seconds
    (fixed-time-window 60
      ; smap passes those events into a function
      (smap (fn [events]
        ; Given a list of events, we'll find the number which have state
        ; warning, divide by the total number of events, and emit a new event
        ; based on the ratio.
        (let [fraction (/ (count (filter #(= "warning" (:state %)) events))
                          (count events))]
          ; The metric for this event will be the fraction of failed signins,
          ; and the state will depend on how many failures we see.
          (event {:service "signin failures"
                  :metric  fraction
                  :state   (condp < fraction
                             0.7 "critical"
                             0.3 "warning"
                                 "ok")})))
        ; Now we can use those "signin failures" events to alert on state
        ; transitions:
        (changed-state (email "ops@trioptimum.com"))))))
{% endhighlight %}
  </div>
</div>

<h3 id="arbitrary-functions-as-streams">Arbitrary functions as streams</h3>
<div class="row">
  <div class="sixcol">
    <p>Since streams are just functions which take an event as their sole
    argument, you can do <i>any</i> computation over events that you like. Just
    write a function, either named or anonymous.</p>

    <p>You can run any Clojure code you like here; using Clojure or Java
    libraries on the classpath, writing to the network, logging to disk, using
    existing variables from the config, and so on. It's up to you.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "foo")
  (fn [event]
    ; Log a message
    (info "I got an event:" event)

    ; Then extract some fields and insert them into a DB.
    (save-to-my-database (:description event) (:metric event))))
{% endhighlight clj %}
  </div>
</div>

<h3 id="create-your-own-stream-function">Create your own stream function</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann builtins like <code>rate</code>, <code>percentiles</code>,
    <code>smap</code>, and so on are all functions which take a variable number
    of child streams and returns a function that takes an event and responds to
    that event. You can build your own stream-generating functions too.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Let's create a trivial example.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn hello-stream [& children]
  (fn [e] (let [new-event (assoc e :hello :world)]
    (call-rescue new-event children))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Our stream returns a function that when it receives an event, adds a new
    key-pair via <code>assoc</code> and then uses <code>call-rescue</code>, a
    standard library function, to pass the event on to all the child streams it
    was passed.</p>

    <p>Add this new stream to the list of event streams.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams (hello-stream prn))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now when you pass an event into Riemann you should see the event printed
    out with an added key-value pair of <code>:hello :world</code>.</p>

    <p>Streams all essentially work in this way, if you look at the source code
    of the Streams namespace in <code>streams.clj</code>. You can find a few
    simple examples in the functions <code>match</code>, <code>expired</code>,
    <code>under</code> and <code>over</code> which filter whether the event is
    passed along the event stream.</p>
  </div>
</div>

<h3>Reinject events</h3>

<div class="row">
  <div class="sixcol">
    <p>To reinsert an event back into the current core, use
    <code>riemann.config/reinject</code>. Reinjected events flow through all
    top-level streams, just as if they had just arrived from the network. In
    this example, incoming "initial" events are remapped to "derivative"
    events and reinjected into the streaming system. Each event is printed
    twice, first "initial", then "derivative".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (streams/where (service "derivative")
    #(info "derivative" %))
  (streams/where (service "initial")
    #(info "initial" %)
    (streams/with :service "derivative" reinject)))
{% endhighlight %}
  </div>
</div>

<h3>Query the index from within a stream</h3>

<div class="row">
  <div class="sixcol">
    <p>Sometimes, you want the behavior of a stream to depend on the current
    state of the index. Say, for instance, that you wanted to use a
    maintenance-mode service to suppress alerting. To enter maintenance mode,
    we'll submit an event to Riemann which has a TTL as long as the maintenance
    window we want. Here's a ten minute window, sent from a Ruby client:</p>
  </div>
  <div class="sixcol last">
{% highlight rb %}
1.9.3p385 :001 > Riemann::Client.new << {service: "maintenance-mode",
                                         host:    nil,
                                         state:   "active",
                                         ttl:     600}
 => nil
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Next, we'll write a function which identifies whether maintenance mode
    is active. We could use <code>riemann.index/lookup</code> to find a
    particular host/service pair, or <code>riemann.index/search</code> for a
    more general query.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn maintenance-mode?
  "Is Riemann currently in maintenance mode?"
  []
  ; Take an expression representing a query for maintenance mode
  (->> '(and (= :host nil)
             (= :service "maintenance-mode"))
       ; Search the current Riemann core's index for any matching events
       (riemann.index/search (:index @core))
       ; Take the first match
       first
       ; Find its state
       :state
       ; Is it the string "active"?
       (= "active")))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Now we can use that function inside of a where predicate, to pass events
    on only when we're *not* in maintenance mode.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (changed-state {:init "ok"}
    (where (not (maintenance-mode?))
      (email "ops@trioptimum.com"))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Naturally, you could parameterize the maintenance-mode function, perhaps
    taking a host, tag, or service as an argument, and searching for particular
    matching events.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn maintenance-mode? [host]
  ; Using (list) to build a query dynamically
  (->> (list 'and (list '= ':host host)
                  '(= :service "maintenance-mode"))
       ...))

(where (not (maintenance-mode? host))
  (email "ops@trioptimum.com"))))
{% endhighlight %}
  </div>
</div>


<h3>Understanding the Riemann stream model</h3>

<div class="row">
  <div class="sixcol">
    <p>Streams are functions that take an event. There's a subtle distinction
    here: we use the term "stream" to describe both the stream <i>itself</i>,
    but also the functions that <i>generate</i> those streams. Remember, in
    Lisp, <code>(fun arg1 arg2)</code> means "Call <code>fun</code> with
    <code>arg1</code> and <code>arg2</code>".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
; A function that generates a stream
rate

; Calling the rate function with the arguments `5` and `index`
; returns a stream: a function that accepts events, computes
; a rate every five seconds, and sends rate events to the index.
(rate 5 index)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Riemann usually calls your streams with events <i>for you</i>. That's
    what the <code>streams</code> function in <code>riemann.config</code>
    means: "here are some functions that you should call when new events
    arrive".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
; Generate a rate stream, then pass that stream to the `streams` function,
; which tells Riemann to remember that stream and call it with each event as
; an argument.
(streams
  (rate 5 index))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>When a new event arrives, Riemann takes each function you've specified
    using `streams` and calls it with that event. Here's the source of
    <code>riemann.core/stream!</code>.</p>

    <p>That's it. Riemann's entire streaming model is just a function call and
    some careful API design. All the functions in <code>riemann.streams</code>,
    like <code>where</code>, <code>rate</code>, <code>with</code>, etc.  take
    streams as arguments and create new streams which call them, usually
    transforming the events they receive in some way.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn stream!
  "Applies an event to the streams in this core."
   [core event]
     (instrumentation/measure-latency (:streaming-metric core)
         (doseq [stream (:streams core))
           (stream event))))
{% endhighlight %}
  </div>
</div>

<h3>Why is my code only running once?</h3>

<div class="row">
  <div class="sixcol">
    <p>New users sometimes have trouble understanding Riemann's execution
    model. For example, you might write a config like this, which is supposed
    to apply the local Riemann server's current time to every event.</p>

    <p>However, this code doesn't do what you might expect. It assigns the
    <i>same</i> time--the time that Riemann last reloaded its config--to every
    event. Why?</p>

    <p>Riemann evaluates the config once at <i>configuration time</i>, building
    up a set of streams and setting up services like logging, the TCP server,
    and so on. Once the config is processed, Riemann begins passing events to
    those streams.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (with :time (unix-time)
    index))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>So, at config time, Riemann follows the normal rules of
    Clojure evaluation, and calls <code>(unix-time)</code> to obtain the
    current server clock.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (with :time 12345
    index))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Then it calls <code>(with :time 12345 index)</code> to build a stream
    that takes events, assigns the time 12345, and sends them to the index.</p>

    <p>Finally, Riemann calls <code>(streams)</code> with that function, telling
    Riemann to apply that stream to all incoming events: assigning the same
    time to all events.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  #<fn-taking-an-event>)
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>To run code each time an event arrives, we need a <i>function</i>. We
    could write a new stream from scratch, or use a stream like
    <code>smap</code> that uses a function to transform each event before
    passing it on to children.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(streams
  (smap (fn [event]
          (assoc event :time (unix-time)))
        index))
{% endhighlight %}
  </div>
</div>

<h3>Calling streams yourself</h3>

<div class="row">
  <div class="sixcol">
    <p>If you use Riemann's built-in stream-generating functions, you don't
    have to worry about calling streams yourself; Riemann does it for you. But
    sometimes, you want to write your own streams, and will need to call some
    child streams yourself.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (fn [event]
    (let [event (assoc event :state "meowing")]
      ; What now???)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>You might try creating a new stream and calling it with the event, but
    this will probably behave weirdly. In this example, every time a new event
    arrives, we create a <i>fresh</i> rate stream, with completely new state,
    and send our event to it. We probably wanted to send each event to the
    <i>same</i> rate stream.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (fn [event]
    (let [event (assoc event :state "meowing")]
      ((rate 5 index) event))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If we're writing a new function to generate streams, we might have our
    downstream children passed in as an argument; see any function in <a
    href="https://github.com/riemann/riemann/blob/master/src/riemann/streams.clj">riemann.streams</a>
  for an example. If we're just defining a one-off stream inline, we can
  <i>bind</i> the child to a variable using <code>let</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (let [downstream (rate 5 index)]
    (fn [event]
      (let [event (assoc event :state "meowing")]
        (downstream event)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>If we want to call <i>multiple</i> downstream children, use
    <code>sdo</code> to wrap them up into a single stream.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (let [downstream (sdo (rate 5 index)
                        prn)]
    (fn [event]
      (let [event (assoc event :state "meowing")]
        (downstream event)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Even easier, in this particular case, is to use a general-purpose
    transformation stream like <code>smap</code>.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(where (service "cat")
  (smap (fn [event]
          (assoc event :state "meowing"))
    (rate 5 index)
    prn))
{% endhighlight %}
  </div>
</div>

<h3>Generating events from within a stream</h3>
<div class="row">
  <div class="sixcol">
    <p>
    There are times where you will want to generate new events
    from an existing stream. Most of the time, it is preferrable
    to use <code>riemann.streams/with</code> to modifying fields
    from an existing event, but there are cases where it would hinder
    readability or it is just not possible. In that case, use
    <code>riemann.common/event</code>.
    </p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(fixed-time-window 60
  (smap (fn [events]
          (let [errors   (filter (comp #{"warning" "critical"} :state) events)
                fraction (/ (count errors) (count events))]
            ; Build a new event using a map of fields and values.
            (event {:service "error percent"
                    :metric fraction})))
    index))
{% endhighlight %}
  </div>
</div>

<h3>Asynchronous streams</h3>

<div class="row">
  <div class="sixcol">
    <p>In Riemann, streams are expressed by <i>function composition</i>. Each
    stream is a function that takes an event and does something with it. Child
    streams are just functions too, so when an event propagates through
    different layers of streams, it's actually just a series of function calls.
    We do this for three reasons:</p>

    <ol>
      <li>Locality. When one function calls another, the event remains on the
      stack--which is almost certainly in CPU cache. If streams were
      asynchronous, we'd have to defer the event to some mutable shared state,
      likely somewhere on the heap. That causes contention: the scheduler is,
      to some degree or another, mutable state being accessed by multiple
      threads, which may have to undergo expensive memory-safety operations. We
      also avoid cache stalls in transfering that event and its processing
      context into and out of some scheduler.</li>

      <li>Hotspot. Modern JVMs aggressively optimize function calls via
      inlining, escape analysis, and other techniques. Asynchronous execution
      makes it harder for the JIT to identify optimization opportunities.
      Because stream handoff is cheap in Riemann, we can use <i>lots</i> of
      streams to solve problems instead of worrying about the handoff cost.
      This means that Riemann's API can break problems into smaller, more
      composable pieces.</li>

      <li>Predictability. It's easier to reason about Riemann stacktraces
      because they have the same structure as the source. It's easier to
      predict when side effects will happen. And backpressure is trivially
      built in; no need to reason about concurrency limits for each
      stream.</li>
    </ol>

    <p>In practice, most Riemann streams are pure functions or only mutate
    in-memory state; Riemann is typically <i>cpu-bound</i>. We have a
    threadpool, on the order of num-processors, which runs an event through all
    streams in the core. This makes Riemann quite fast--but when you make a
    blocking call to a downstream service, sometimes the rules change. You
    <i>want</i> additional parallelism for IO, or an explicit queue in between
    two streams. In keeping with the Riemann philosphy of small, re-usable
    components, you can make <i>any</i> stream asynchronous, with its own
    bounded queue, worker threadpool, and performance metrics, via the
    <code>async-queue!</code> stream.</p>
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>For instance, the <code>forward</code> stream forwards events to another
    Riemann server, and returns only when that server has acknowledged the
    message. This provides backpressure and acknowledgement: a client knows
    that its message was accepted not only by the local Riemann server, but also
    by the downstream Riemann server.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(let [index (index)]
  (streams
    (forward (riemann.client/tcp-client :host "agg.riemann.prod"))
    index))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>But if that link is slow, and we want to return <i>immediately</i>, we
    can defer execution of that stream onto a threadpool via a fixed-size
    queue.  Because we acknowledge before the downstream server acknowledges,
    we might falsely acknowledge a message. The semantics of the stream have
    changed; we're gaining performance and insensitivity to downstream latency,
    but at the cost of safety.</p>

    <p>We <i>bound</i> the number of in-flight operations to the downstream
    service by specifying how many threads are allowed, and bound memory
    consumption via the queue size. If the queue fills up, events passed to the
    async-queue stream will immediately throw an exception informing you that
    the queue is full; as with all exceptions in Riemann, you can explicitly
    catch them using an exception handler stream, or allow Riemann to log the
    failure. As with all Riemann streams, exceptions don't interfere with other
    child streams.</p>

    <p>All async-queue services support hot config reloading (though they won't
    cleanly drain events between services if their parameters change), and come
    with internal metric events about their queue size, outstanding threads,
    etc. They'll alert you via state changes if they get too full, so make sure
    to monitor events like "riemann executor rejected rate" with
    <code>changed-state</code> so you'll know when they start dropping
    events.</p>

    <p>Note the bang (<code>!</code>) at the end of <code>async-queue</code>;
    this function <i>is dangerous because it mutates state</i>. Async-queue
    creates a threadpool and changes the Riemann core. You *don't* want to
    create these dynamically, or you could wind up with hundreds or thousands
    of queues and threadpools. Never put an async-queue inside of a
    <code>by</code>, for example: <code>by</code> would create a new async
    queue for each distinct host or service, etc. For safety, define your
    async-queue streams in a let binding, and call them wherever needed in
    <code>streams</code>. That way you'll know it's always the <i>same</i>
    executor.</p>

    <p>Remember, you can wrap <i>any</i> stream in this asynchronous layer.
    Combining batching and async-queue can dramatically improve throughput;
    sometimes by several orders of magnitude. Each has its cost: batching
    increases latency, and async-queue means dropping events if the queue fills
    up. As a transient event processor, Riemann emphasizes *dropping* old data
    rather than getting backed up or shutting down entirely. Think of
    async-queue like a safety valve; allowing you to still process requests by
    shunting some of the incoming stream aside. If you want <i>guaranteed</i>
    delivery over long timescales, use an on-disk queuing system like Kafka,
    either in front of or behind Riemann.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (index)
      downstream (async-queue!
                    :agg-forwarder        ; A name for the forwarder
                    {:queue-size     1e4  ; 10,000 events max
                     :core-pool-size 4    ; Minimum 4 threads
                     :max-pool-size 100}  ; Maximum 100 threads
                    (forward
                      (riemann.client/tcp-client :host "127.0.0.1")))]
  (streams
    index
    ; We'll accumulate batches of at most 100 events every 10th of a second
    ; before sending those events downstream to the other Riemann node, via
    ; the async queue.
    (batch 100 1/10
      downstream)))
{% endhighlight %}
  </div>
</div>

<h3>Organizing with functions</h3>

<div class="row">
  <div class="sixcol">
    <p>Riemann's config is a Clojure program; you can break up your config into
    smaller, testable, re-usable pieces using <i>functions</i>, and organize
    those functions into <i>namespaces</i>. For example, here's a config which
    computes rates and percentiles over two different services.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (index)
      graph (graphite {:host "graphs.internal")]
  (streams
    (where (service "foo")
      (by :host
        (with {:metric 1, :service "foo rate"}
          (rate 5 index graph))
        (percentiles 5 [0.5 0.95 0.99] index graph)))

    (where (service "bar")
      (by :host
        (with {:metric 1, :service "bar rate"}
          (rate 5 index graph))
        (percentiles 5 [0.5 0.95 0.99] index graph)))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Let's break that rate and percentile pattern out into its own function.
    The two <code>where</code> expressions match <i>different</i> services, so
    we'll make the service name an argument to the function. We also need to
    send our rate and latency events to two child streams--the index, and the
    graphite client--so we'll make those the two arguments to the function. The
    function will construct a stream using <code>(where ...)</code> and return
    that to its caller.</p>

    <p><code>(defn ...)</code> defines a new function, named
    <code>rate+percentiles</code>. We provide a docstring that describes the
    function, and a list of arguments in <code>[brackets]</code>. Then we
    create a stream using <code>where</code>. The final (in this case only)
    expression in a <code>defn</code> is the function's return value.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(defn rate+percentiles
  "Filters events to those with the given service, then, for each host,
  compute a rate and percentile distribution every 5 seconds, and forward
  those events to the given index and graphite client."
  [svc index graph]
  (where (= service svc)
    (by :host
      (with {:metric 1, :service (str svc " rate")}
        (rate 5 index graph))
      (percentiles 5 [0.5 0.95 0.99] index graph))))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>Then we just <i>call</i> that function in our streams, filling in the
    service, index, and graphite client we'd like to send events to. Remember,
    in Clojure, <code>(fun a b)</code> means "call the function
    <code>fun</code> with arguments <code>a</code> and <code>b</code>".</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(let [index (index)
      graph (graphite {:host "graphs.internal")]
  (streams
    (rate+percentiles "foo" index graph)
    (rate+percentiles "bar" index graph)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>These functions can, in turn, call <i>other</i> functions, allowing you
    to build up complex streams out of small, well-organized parts.
<i>Everything</i> in Riemann is defined in terms of functions like this: the
same tools we use to build Riemann's internals are in your hands too.</p>

   <p>Use functions whenever you start nesting too deeply, or whenever you can
put a name to a well-defined stream. Use functions to transform events! Use
functions to figure out what time it is! There's no limit. For more on
functions and Clojure in general, see <a
href="https://aphyr.com/posts/303-clojure-from-the-ground-up-functions">Clojure
from the Ground Up: Functions</a>.</p>
  </div>
</div>

<h3>Organizing with namespaces</h3>

<div class="row">
  <div class="sixcol">
    <p>As your config grows, you'll have more and more functions--and more and
more <i>names</i> to worry about. It helps to break things up into
<i>namespaces</i>--typically one per file. Clojure provides a first-class
namespace system, which you can use to organize your configuration. For
instance, we might have a file in <code>/etc/riemann/mycorp/queue.clj</code>
which knows how to handle all the events from a queuing system.</p>

    <p>We start the file with a namespace declaration <code>ns</code>, and pull
in some common Riemann functions using <code>:require</code>. If you need
functions from other namespaces, you can add them as well. Then we define functions that help build queue-related streams.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(ns mycorp.queue
  "Instrumentation and alerts for our distributed queue and consumers"
  (:require [riemann.config :refer :all]
            [riemann.streams :refer :all]))

(defn capacity [index pagerduty] ...)

(defn rate-of-growth [index pagerduty] ...)

(defn queues
  "Handles all queuing events."
  [index pagerduty]
  ; We'll just route all events to each of these streams
  (sdo
    (capacity       index pagerduty)
    (rate-of-growth index pagerduty)))
{% endhighlight %}
  </div>
</div>

<div class="row">
  <div class="sixcol">
    <p>In our top-level <code>riemann.config</code>, we don't want to worry
about capacities or rates of growth or anything else. We'll just load every
<code>.clj</code> file in the <code>mycorp</code> directory, and require the
<code>mycorp.queues</code> namespace, giving it the short name <code>q</code>.
Then we can call any function from that namespace using
<code>q/some-fn</code>.</p>

    <p>Note that <code>require</code> has a slightly different shape in a
<code>ns</code> declaration versus when it's called as a function: when called
as a function, we put a single quote in front of the vector. There are Good
Reasons (TM) for Clojure to work this way, but it's a long story and we won't
dig into it here.</p>
  </div>
  <div class="sixcol last">
{% highlight clj %}
(include "mycorp/")
(require '[mycorp.queue :as q])

(let [index (index)
      pd    (pagerduty ...)]
  (streams
    (where (service #"queue ")
      (q/queues index pd))))
{% endhighlight %}
  </div>
</div>

<h2>Working with the dashboard</h2>

<h3>Find out what services are in the index</h3>

<div class="row">
  <div class="sixcol">
    <p>Some producers, like collectd, spew a huge volume of service into
    Riemann, which can make it tough to figure out which service to use. You
    can dump every service from the Riemann index with a client in your
    favorite language, though. Just issue a query (e.g. <code>true</code> for
    all events, though this might be slow), and extract the fields you're
    interested in.</p>
  </div>
  <div class="sixcol last">
{% highlight sh %}
gem install riemann-client
irb -r riemann/client
{% endhighlight %}

{% highlight rb %}
Riemann::Client.new(host: "my.riemann.server")["true"].map(&:service).sort.uniq.each { |x| puts x }
{% endhighlight %}
  </div>
</div>

<h2>Integrating with other systems</h2>

<div class="row">
  <div class="sixcol">
    <p>Make sure to check the <a href="#asynchronous-streams">asynchronous
      streams</a> docs; it may be appropriate to batch or defer events which
    flow to downstream systems.</p>
  </div>
</div>

<h3>Send email</h3>

<div class="row">
  <div class="sixcol">
    <p><code>riemann.email</code> can send single events--or vectors of events--via email.</p>

    <p>You can use any options for <a href="https://github.com/drewr/postal">Postal</a>.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(let [email (mailer {:from "riemann@trioptimum.com"})]
  (streams
    (where (state "critical")
      (email "shodan@tauceti.five"))))
{% endhighlight %}

{% highlight clj %}
(mailer {:from "riemann@trioptimum.com"
         :host "mx1.trioptimum.com"
         :user "foo"
         :pass "bar"})
{% endhighlight %}
  </div>
</div>

<h3>Forward to Graphite</h3>

<div class="row">
  <div class="sixcol">

  <p>First, you define a client to graphite, which maintains a connection pool.</p>

  <p>Then, use the client as a stream.</p>

  <p>Or just graph everything.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(def graph (graphite {:host "my.graphite.server"}))
{% endhighlight %}

{% highlight clj %}
(streams
  (where (service "thing-to-graph")
    graph))
{% endhighlight %}

{% highlight clj %}
(streams
  graph)
{% endhighlight %}
  </div>
</div>

<h3>Forward to Librato Metrics</h3>

<div class="row">
  <div class="sixcol">
<p>Create a client for librato-metrics with your username and API key.</p>

<p>Then use it in streams.</p>

<p>You can submit events as annotations too. See the <a href="api/riemann.librato.html#var-librato-metrics">librato-metrics documentation</a>.</p>
  </div>

  <div class="sixcol last">

{% highlight clj %}
(def librato (librato-metrics \"aphyr@aphyr.com\" \"abcd01234...\"))
{% endhighlight %}

{% highlight clj %}
(streams
  (tagged \"latency\" (librato :gauge)))
{% endhighlight %}

  </div>
</div>

<h3>Notify with Pagerduty</h3>

<div class="row">
  <div class="sixcol">

    <p>Create a <a href="http://riemann.io/api/riemann.pagerduty.html#var-pagerduty">client</a> with your Pagerduty service key, then use <code>:trigger</code> and <code>:resolve</code> to open and close issues for a given host and service.</p>

    <p>You can also pass http options using the <code>:options</code> key, and a custom formatter for the Pagerduty event with the <code>:formatter</code> key.</p>

    <p>You can use the <a href="https://v2.developer.pagerduty.com/docs/send-an-event-events-api-v2">Pagerduty v2 API</a> by setting the <code>:version</code> key to <code>:v2</code>. In v2, each event can contain a <code>:dedup-key</code> key to handle alert de-duplication.
</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(let [pd (pagerduty {:service-key "my-service-key"
                     :options {:proxy-host "127.0.0.1"
                               :proxy-port 8118}})]
  (streams
    (changed-state
      (where (state "ok")
        (:resolve pd)
        (else (:trigger pd))))))
{% endhighlight %}
  </div>
</div>

<h3>Sent events to Slack</h3>

<div class="row">
  <div class="sixcol">
  <p>Create a <a href="https://api.slack.com/incoming-webhooks">Slack webhook</a> for Riemann. Then create a Slack client using the token from the last element of your
  webhook URL, for example with a URL of:</p>

  <small>https://hooks.slack.com/services/QWERSAFG0/AFOIUYTQ48/120984SAFJSFR</small>

  <p>Then your token would be <code>120984SAFJSFR</code>. Specify the user name of the Riemann bot, a channel to notify in and an icon for the notification.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(def credentials {:account "your_org", :token "your_token"})
(def slacker (slack credentials {:username "Riemann bot"
                                 :channel "#ops"
                                 :icon ":smile:"}))

(streams
    (where (state "critical")
      slacker))
{% endhighlight %}
  </div>
</div>

<h3>Forward between Riemann servers</h3>

<div class="row">
  <div class="sixcol">
<p>When you have *many* events, you can use multiple Riemann servers to scale
out. You might, for instance, run one Riemann server per data center, and
forward only state changes in each service to a master server for a birds-eye
view.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(streams
  (let [client (tcp-client :host "aggregator")]
    (by [:host :service]
       (changed :state
                (forward client)))))
{% endhighlight %}
  </div>
</div>

<h3>Forward to InfluxDB</h3>

<div class="row">
  <div class="sixcol">

  <p>Create a <a href="api/riemann.influxdb.html#var-influxdb">InfluxDB</a> client for Riemann. Using <code>:version :new-stream</code> allows to use the <a href="api/riemann.influxdb.html#var-influxdb-new-stream">new</a> InfluxDB stream. Otherwise, the <a href="api/riemann.influxdb.html#var-influxdb-deprecated">old</a> stream is used.</p>

  <p>You can then send events to InfluxDB. You can use <code>smap</code> for example to format events for the new stream. </p>

  <p>For the old stream, you can override per event the <code>:tag-fields</code> and <code>:precision</code> options. For the new stream, you can override per event <code>:consistency</code>, <code>:db</code>, <code>:retention</code> and <code>:precision</code>.</p>

  <p>If a field is a Clojure <code>Ratio</code>, it will be converted to <code>Double</code></p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(def influx (influxdb {:host "localhost"
                       :db "riemann"
                       :version :new-stream}))
{% endhighlight %}

{% highlight clj %}
(streams
  (smap
    (fn [event]
      (assoc event :measurement     (:service event)
                   :influxdb-tags   {:state (:state event)}
                   ;; :value = 0 by default
                   :influxdb-fields {:value (or (:metric event) 0)}))
    influx))
{% endhighlight %}
  </div>
</div>

<h3>Kafka Integration</h3>

<h4>Consume from Kafka</h4>

<div class="row">
  <div class="sixcol">
    <p>You can consume events from Kafka topics by configuring a <a href="api/riemann.config.html#var-kafka-consumer">Kafka consumer</a>.</p>
    <p>For a full list of <code>:consumer.config</code> options see the Kafka consumer docs. Note that the <code>:enable.auto.commit</code> option is ignored and defaults to true.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(kafka-consumer {:consumer.config {:bootstrap.servers "brok01.foo:9092"
                                   :group.id "riemann"}
                 :topics ["metrics"]})
{% endhighlight %}
  </div>
</div>

<h4>Forward to Kafka</h4>

<div class="row">
  <div class="sixcol">
    <p>Create a <a href="api/riemann.kafka.html#var-kafka">Kafka</a> client. For a complete list of producer configuration options see <a href="https://kafka.apache.org/documentation/#producerconfigs">the Kafka documentation</a>. The Kafka stream uses <a href="https://github.com/pyr/kinsky">kinsky</a> under the hood, so you can import it and use these serializers.</p>
    <p>You can now call <code>kafka-output</code> in your streams with a topic name and an optional message key.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(def kafka-output (kafka {:bootstrap.servers "brok01.foo:9092"}))

(streams
  (kafka-output "my-topic"))

{% endhighlight %}
  </div>
</div>

<h3>Forward to Elasticsearch</h3>

<div class="row">
  <div class="sixcol">
    <p>Create a <a href="http://riemann.io/api/riemann.elasticsearch.html#var-elasticsearch"> Elasticsearch</a> client. The elasticsearch stream accepts an optional second parameter specifying an event formatter (see the API documentation for the default value).</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(def elastic
  (elasticsearch {:es-endpoint "http://localhost:9200"
                  :es-index "riemann"
                  :index-suffix "-yyyy.MM.dd"
                  :type "event"}))
(streams
 elastic)

{% endhighlight %}
  </div>

  <div class="sixcol">
    <p>You can also use the Elasticsearch <a href="http://riemann.io/api/riemann.elasticsearch.html#var-elasticsearch-bulk">bulk API</a>. You can override per event the <code>default-bulk-formatter</code> options.</p>
  </div>

  <div class="sixcol last">
{% highlight clj %}
(def elastic-bulk
  (elasticsearch-bulk
    {:es-endpoint "http://localhost:9200"
     :formatter (riemann.elasticsearch/default-bulk-formatter
                  {:es-index "riemann"
                   :type "event"
                   :index-suffix "-yyyy.MM.dd"
                   :es-action "index"})}))

(streams
  (batch 100 1/10
    elastic-bulk))

{% endhighlight %}
  </div>
</div>

<h2>Contributing to Riemann</h2>

<h3>Write a client</h3>

<p>A TCP connection to Riemann is a stream of messages. Each message is a 4
byte network-endian integer *length*, followed by a Protocol Buffer Message of
*length* bytes. See the <a
  href="https://github.com/riemann/riemann-java-client/blob/master/riemann-java-client/src/main/proto/riemann/proto.proto">protocol
  buffer definition</a> for the details.</p>

<p>Over UDP, the length header is omitted; just send the protobuf Message
directly. UDP datagrams have a default maximum size of 16384 bytes by
Riemann's default; larger messages should go over TCP. This limit is
configurable in both the client and server; client values *must* be smaller
than the server's.</p>

<p>The server will accept a repeated list of Events, and respond with a
confirmation message with either an acknowledgement or an error. Check the <code>ok</code>
boolean in the message; if false, <code>message.error</code> will be a descriptive
string.</p>

<p>Because protocol buffers is a strongly typed protocol, the metric of an
event is represented as one of metric_d (floating point 64-bit), metric_f
(floating point 32-bit), or metric_sint64 (64-bit signed integer). Your client
should emit and consume all of these types. For compatibility with older
versions of Riemann, you may *also* emit a metric_f alongside the normal type;
newer versions of Riemann will prefer the higher-resolution types.</p>

<p>Events are uniquely identified by host and service. Both allow null.
Event.time is the time in unix epoch seconds and is optional. The server will generate a time for each event when received if you do not provide one. Event.time_micros is the time in unix epoch microseconds and is optional too. When receiving a protobuf message, Riemann will use time_micros in priority.</p>

<p>You can also query events from the index using a basic query language. Just
submit a Message with your query in message.query.string. Search queries will
return a message with repeated Events matching that expression. A null
expression will return no states. For some example queries, see <a
  href="https://github.com/riemann/riemann/blob/master/test/riemann/query_test.clj">The
  query test suite</a>.</p>

<p>You might find it useful to read the <a
  href="https://github.com/riemann/riemann-ruby-client">Ruby client</a> source as
a guide to writing your own client.</p>

<h3>Work with the Riemann source</h3>

<p>I try to keep master as clean and runnable as possible. Riemann has an
exhaustive test suite, which helps ensure code quality. If you plan on changing
the Riemann source, fork it on Github so you'll be able to send pull requests
quickly. If you just want to run the latest version, go ahead and clone the
official repo:</p>

{% highlight sh %}
git clone git://github.com/riemann/riemann.git
cd riemann
{% endhighlight %}

<p>You'll also need a JVM, and <a
  href="https://github.com/technomancy/leiningen">leiningen 2</a>--the Clojure
build system.</p>

<p>To run the tests suite, try <code>lein test</code>. To start Riemann, run
<code>lein run</code>. Riemann will read the file <code>riemann.config</code>
in the current directory. If you want to run a different config file, try</p>

{% highlight sh %} lein run -- path/to/my/riemann.config {% endhighlight %}

<p>If you want a fat jar, run <code>lein uberjar</code> and copy
target/riemann-{version}-STANDALONE.jar. To build tarball and debian packages,
use <code>lein pkg</code>; .debs and .tar.gz files, plus md5sums, will appear
in <code>target/</code>.

<p>The protocol buffer codec and clojure client live in <a
  href="https://github.com/riemann/riemann-clojure-client">riemann-clojure-client</a>,
which wraps the java protobuf code and java client in <a
  href="https://github.com/riemann/riemann-java-client">riemann-java-client</a>.
Both of these are available on clojars and most of the time you can ignore
them. However, if you need to change the protocol or client, you can fork these
projects and make your changes there.</p>

<h3>Building riemann-java-client</h3>

<p>You'll need maven, and the protocol buffers compiler (protoc) version
2.4.1.</p>

<p>When you've made changes to the java client, install it with <code>mvn
  install</code>; then test the clojure client and install it with <code>lein
  install</code>. Finally, you can run riemann itself. You may need to check
that the client versions you're working with match up in the riemann and
riemann-clojure-clientproject.clj files.</p>

<h3>Fix a bug or add a feature</h3>

<p>First, <a href="https://github.com/riemann/riemann">fork Riemann on
  github</a>. Clone your fork and create a new topic branch for your fix:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout -b fix-some-bug
{% endhighlight %}

<p>Most of Riemann's source lives in <code>src/riemann/</code>. Corresponding
tests live in <code>test/riemann/</code>. When you fix a bug or add a
feature, make sure to add new tests that confirm its correctness! You can run
the test suite with</p>

{% highlight sh %}
lein test
{% endhighlight %}

<p>Some tests for integrating with other services require a local sendmail, or
graphite, or credentials for a web service. If you make changes that affect
these systems, you can test them with special selectors like <code>lein test
  :graphite</code> or <code>lein test :email</code>. If you're working with a
particular namespace, like <code>riemann.streams</code>, <code>lein test
  riemann.streams-test</code> runs only the tests for that namespace. Once your
tests pass, commit your changes and push them to github:</p>

{% highlight sh %}
git commit -a
git push origin fix-some-bug
{% endhighlight %}

<p>If you change more than a few lines of whitespace, please make your
formatting changes in a separate commit; it'll be easier for me to read and
understand your changes. Please try to send me only a few commits where
possible; use <code>rebase --interactive</code> to squash your small
changes.</p>

<h3>Help write documentation</h3>

<p>Riemann's web site and documentation are in the gh-pages branch of the
riemann repository. <a href="https://github.com/riemann/riemann">Fork riemann on
  github</a>, clone your fork, and check out the branch:</p>

{% highlight sh %}
git clone git@github.com:your-github-username/riemann.git
cd riemann
git checkout gh-pages
vim howto.html
{% endhighlight %}

<p>Pages are built with Jekyll. To see how your changes will appear on the site,</p>

{% highlight sh %}
sudo apt-get install python-pygments jekyll
cd riemann
jekyll serve
{% endhighlight %}

<p>... and open _site/howto.html in a web browser. When you're satisfied with
your changes, commit, push, and send me a pull request:</p>

{% highlight sh %}
git commit -am "Added a howto guide for integrating with FooService"
git push
{% endhighlight %}

    </div>
  </div>
</div>
