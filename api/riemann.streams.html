<!DOCTYPE html PUBLIC ""
    "">

<html><head><meta charset="UTF-8" /><title>riemann.streams documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Riemann</span> <span class="project-version">0.3.12</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>riemann</span></div></div></li><li class="depth-2 branch"><a href="riemann.bin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bin</span></div></a></li><li class="depth-2 branch"><a href="riemann.blueflood.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>blueflood</span></div></a></li><li class="depth-2 branch"><a href="riemann.boundary.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>boundary</span></div></a></li><li class="depth-2 branch"><a href="riemann.clickhouse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clickhouse</span></div></a></li><li class="depth-2 branch"><a href="riemann.cloudwatch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cloudwatch</span></div></a></li><li class="depth-2 branch"><a href="riemann.common.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></a></li><li class="depth-2 branch"><a href="riemann.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch"><a href="riemann.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="riemann.datadog.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datadog</span></div></a></li><li class="depth-2 branch"><a href="riemann.deps.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deps</span></div></a></li><li class="depth-2 branch"><a href="riemann.druid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>druid</span></div></a></li><li class="depth-2 branch"><a href="riemann.elasticsearch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>elasticsearch</span></div></a></li><li class="depth-2 branch"><a href="riemann.email.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>email</span></div></a></li><li class="depth-2 branch"><a href="riemann.expiration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>expiration</span></div></a></li><li class="depth-2 branch"><a href="riemann.folds.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>folds</span></div></a></li><li class="depth-2 branch"><a href="riemann.graphite.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graphite</span></div></a></li><li class="depth-2 branch"><a href="riemann.hipchat.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hipchat</span></div></a></li><li class="depth-2 branch"><a href="riemann.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-2 branch"><a href="riemann.influxdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>influxdb</span></div></a></li><li class="depth-2 branch"><a href="riemann.influxdb2.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>influxdb2</span></div></a></li><li class="depth-2 branch"><a href="riemann.instrumentation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>instrumentation</span></div></a></li><li class="depth-2 branch"><a href="riemann.kafka.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kafka</span></div></a></li><li class="depth-2 branch"><a href="riemann.kairosdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kairosdb</span></div></a></li><li class="depth-2 branch"><a href="riemann.keenio.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>keenio</span></div></a></li><li class="depth-2 branch"><a href="riemann.librato.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>librato</span></div></a></li><li class="depth-2 branch"><a href="riemann.logentries.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>logentries</span></div></a></li><li class="depth-2 branch"><a href="riemann.logging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>logging</span></div></a></li><li class="depth-2 branch"><a href="riemann.logstash.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>logstash</span></div></a></li><li class="depth-2 branch"><a href="riemann.mailgun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mailgun</span></div></a></li><li class="depth-2 branch"><a href="riemann.msteams.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>msteams</span></div></a></li><li class="depth-2 branch"><a href="riemann.nagios.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nagios</span></div></a></li><li class="depth-2 branch"><a href="riemann.netuitive.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>netuitive</span></div></a></li><li class="depth-2 branch"><a href="riemann.opentsdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>opentsdb</span></div></a></li><li class="depth-2 branch"><a href="riemann.opsgenie.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>opsgenie</span></div></a></li><li class="depth-2 branch"><a href="riemann.pagerduty.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pagerduty</span></div></a></li><li class="depth-2 branch"><a href="riemann.plugin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plugin</span></div></a></li><li class="depth-2 branch"><a href="riemann.pool.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pool</span></div></a></li><li class="depth-2 branch"><a href="riemann.prometheus.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>prometheus</span></div></a></li><li class="depth-2 branch"><a href="riemann.pubsub.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pubsub</span></div></a></li><li class="depth-2 branch"><a href="riemann.pushover.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pushover</span></div></a></li><li class="depth-2 branch"><a href="riemann.query.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li><li class="depth-2 branch"><a href="riemann.rabbitmq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rabbitmq</span></div></a></li><li class="depth-2 branch"><a href="riemann.repl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>repl</span></div></a></li><li class="depth-2 branch"><a href="riemann.service.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>service</span></div></a></li><li class="depth-2 branch"><a href="riemann.shinken.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>shinken</span></div></a></li><li class="depth-2 branch"><a href="riemann.slack.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>slack</span></div></a></li><li class="depth-2 branch"><a href="riemann.sns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sns</span></div></a></li><li class="depth-2 branch"><a href="riemann.stackdriver.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stackdriver</span></div></a></li><li class="depth-2 current"><a href="riemann.streams.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>streams</span></div></a></li><li class="depth-3"><a href="riemann.streams.pure.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pure</span></div></a></li><li class="depth-2 branch"><a href="riemann.telegram.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>telegram</span></div></a></li><li class="depth-2 branch"><a href="riemann.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2"><a href="riemann.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-3"><a href="riemann.time.controlled.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>controlled</span></div></a></li><li class="depth-2"><a href="riemann.transport.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>transport</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.debug.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debug</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.graphite.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graphite</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.opentsdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>opentsdb</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.rabbitmq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rabbitmq</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.sse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sse</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.tcp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tcp</span></div></a></li><li class="depth-3 branch"><a href="riemann.transport.udp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>udp</span></div></a></li><li class="depth-3"><a href="riemann.transport.websockets.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>websockets</span></div></a></li><li class="depth-2 branch"><a href="riemann.twilio.html"><div class="inner"><span class="tree" style="top: -269px;"><span class="top" style="height: 278px;"></span><span class="bottom"></span></span><span>twilio</span></div></a></li><li class="depth-2 branch"><a href="riemann.victorops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>victorops</span></div></a></li><li class="depth-2 branch"><a href="riemann.xymon.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xymon</span></div></a></li><li class="depth-2"><a href="riemann.zabbix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>zabbix</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="riemann.streams.html#var-*exception-stream*"><div class="inner"><span>*exception-stream*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var--infinity"><div class="inner"><span>-infinity</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-adjust"><div class="inner"><span>adjust</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-apdex"><div class="inner"><span>apdex</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-apdex*"><div class="inner"><span>apdex*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-batch"><div class="inner"><span>batch</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-bit-bucket"><div class="inner"><span>bit-bucket</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-by"><div class="inner"><span>by</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-by-builder"><div class="inner"><span>by-builder</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-by-fn"><div class="inner"><span>by-fn</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-call-rescue"><div class="inner"><span>call-rescue</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-changed"><div class="inner"><span>changed</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-changed-state"><div class="inner"><span>changed-state</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-clock-skew"><div class="inner"><span>clock-skew</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-coalesce"><div class="inner"><span>coalesce</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-coalesce-with-event"><div class="inner"><span>coalesce-with-event</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-counter"><div class="inner"><span>counter</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-ddt"><div class="inner"><span>ddt</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-ddt-events"><div class="inner"><span>ddt-events</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-ddt-real"><div class="inner"><span>ddt-real</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-default"><div class="inner"><span>default</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-dual"><div class="inner"><span>dual</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-ewma"><div class="inner"><span>ewma</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-ewma-timeless"><div class="inner"><span>ewma-timeless</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-exception-stream"><div class="inner"><span>exception-stream</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-execute-on"><div class="inner"><span>execute-on</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-expired"><div class="inner"><span>expired</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-expired.3F"><div class="inner"><span>expired?</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fill-in"><div class="inner"><span>fill-in</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fill-in-last"><div class="inner"><span>fill-in-last</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fill-in-last*"><div class="inner"><span>fill-in-last*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fixed-event-window"><div class="inner"><span>fixed-event-window</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fixed-offset-time-window"><div class="inner"><span>fixed-offset-time-window</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fixed-time-window"><div class="inner"><span>fixed-time-window</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fold-interval"><div class="inner"><span>fold-interval</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-fold-interval-metric"><div class="inner"><span>fold-interval-metric</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-forward"><div class="inner"><span>forward</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-infinity"><div class="inner"><span>infinity</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-interpolate-constant"><div class="inner"><span>interpolate-constant</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-match"><div class="inner"><span>match</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-mean-over-time"><div class="inner"><span>mean-over-time</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-moving-event-window"><div class="inner"><span>moving-event-window</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-moving-time-window"><div class="inner"><span>moving-time-window</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-not-expired"><div class="inner"><span>not-expired</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-over"><div class="inner"><span>over</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-part-time-fast"><div class="inner"><span>part-time-fast</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-part-time-simple"><div class="inner"><span>part-time-simple</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-percentiles"><div class="inner"><span>percentiles</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-periodically-until-expired"><div class="inner"><span>periodically-until-expired</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-pipe"><div class="inner"><span>pipe</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-predict-linear"><div class="inner"><span>predict-linear</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-project"><div class="inner"><span>project</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-project*"><div class="inner"><span>project*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-rate"><div class="inner"><span>rate</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-register"><div class="inner"><span>register</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-rollup"><div class="inner"><span>rollup</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-runs"><div class="inner"><span>runs</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-scale"><div class="inner"><span>scale</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-sdo"><div class="inner"><span>sdo</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-sflatten"><div class="inner"><span>sflatten</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-smap"><div class="inner"><span>smap</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-smap*"><div class="inner"><span>smap*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-smapcat"><div class="inner"><span>smapcat</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-split"><div class="inner"><span>split</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-split*"><div class="inner"><span>split*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-split*-match"><div class="inner"><span>split*-match</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-splitp"><div class="inner"><span>splitp</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-sreduce"><div class="inner"><span>sreduce</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-stable"><div class="inner"><span>stable</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-stream"><div class="inner"><span>stream</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-sum-over-time"><div class="inner"><span>sum-over-time</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-tag"><div class="inner"><span>tag</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-tagged"><div class="inner"><span>tagged</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-tagged-all"><div class="inner"><span>tagged-all</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-tagged-all.3F"><div class="inner"><span>tagged-all?</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-tagged-any"><div class="inner"><span>tagged-any</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-tagged-any.3F"><div class="inner"><span>tagged-any?</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-throttle"><div class="inner"><span>throttle</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-top"><div class="inner"><span>top</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-under"><div class="inner"><span>under</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-untag"><div class="inner"><span>untag</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-where"><div class="inner"><span>where</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-where*"><div class="inner"><span>where*</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-where-partition-clauses"><div class="inner"><span>where-partition-clauses</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-where-rewrite"><div class="inner"><span>where-rewrite</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-window"><div class="inner"><span>window</span></div></a></li><li class="depth-1"><a href="riemann.streams.html#var-with"><div class="inner"><span>with</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">riemann.streams</h1><div class="doc"><div class="markdown"><p>The streams namespace aims to provide a comprehensive set of widely applicable, combinable tools for building more complex streams.</p>
<p>Streams are functions which accept events or, in some cases, lists of events.</p>
<p>Streams typically do one or more of the following.</p>
<ul>
<li>Filter events.</li>
<li>Transform events.</li>
<li>Combine events over time.</li>
<li>Apply events to other streams.</li>
<li>Forward events to other services.</li>
</ul>
<p>Most streams accept, after their initial arguments, any number of streams as children. These are known as children or “child streams” of the stream. The children are typically invoked sequentially, any exceptions thrown are caught, logged and optionally forwarded to <em>exception-stream</em>. Return values of children are ignored.</p>
<p>Events are backed by a map (e.g. {:service “foo” :metric 3.5}), so any function that accepts maps will work with events. Common functions like prn can be used as a child stream.</p>
<p>Some common patterns for defining child streams are (fn <a href="e">e</a>(println e)) and (partial log :info).</p>
</div></div><div class="public anchor" id="var-*exception-stream*"><h3>*exception-stream*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>When an exception is caught, it’s converted to an event and sent here.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L46">view source</a></div></div><div class="public anchor" id="var--infinity"><h3>-infinity</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L44">view source</a></div></div><div class="public anchor" id="var-adjust"><h3>adjust</h3><div class="usage"><code>(adjust &amp; args)</code></div><div class="doc"><div class="markdown"><p>Passes on a changed version of each event by applying a function to a particular field or to the event as a whole.</p>
<p>Passing a vector of <a href="field function &amp; args">field function &amp; args</a> to adjust will modify the given field in incoming events by applying the function to it along with the given arguments.  For example:</p>
<p>(adjust <a href=":service str &quot; rate&quot;">:service str " rate"</a> …)</p>
<p>takes {:service “foo”} and emits {:service “foo rate”}.</p>
<p>If a function is passed to adjust instead of a vector, adjust behaves like smap: the entire event will be given to the function and the result will be passed along to the children. For example:</p>
<p>(adjust #(assoc % :metric (count (:tags %))) …)</p>
<p>takes {:tags <a href="&quot;foo&quot; &quot;bar&quot;">“foo” “bar”</a>} and emits {:tags <a href="&quot;foo&quot; &quot;bar&quot;">“foo” “bar”</a> :metric 2}.</p>
<p>Prefer (smap f &amp; children) to (adjust f &amp; children) where possible.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1419">view source</a></div></div><div class="public anchor" id="var-apdex"><h3>apdex</h3><h4 class="type">macro</h4><div class="usage"><code>(apdex dt satisfied? tolerated? &amp; children)</code></div><div class="doc"><div class="markdown"><p>A stream which computes Apdex metrics every dt seconds for a stream of events. Satisfied? and tolerated? are predicates as for (where). If satisfied is truthy, increments the satisfied count for that time window by 1. If (tolerated? event) is truthy, increments the tolerated count for that time window by 1. Any other states are ignored. Every dt seconds (as long as events are arriving), emits an event with a metric between 0 and 1, derived by:</p>
<p>(satisfied count + (tolerating count / 2) / total count of received events</p>
<p>Ignores expired events.</p>
<p>See <a href="http://en.wikipedia.org/wiki/Apdex">http://en.wikipedia.org/wiki/Apdex</a> for details.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L2142">view source</a></div></div><div class="public anchor" id="var-apdex*"><h3>apdex*</h3><div class="usage"><code>(apdex* dt satisfied? tolerated? &amp; children)</code></div><div class="doc"><div class="markdown"><p>Like apdex, but takes functions of events rather than where-predicates.</p>
<p>A stream which computes Apdex metrics every dt seconds for a stream of events. If (satisfied? event) is truthy, increments the satisfied count for that time window by 1. If (tolerated? event) is truthy, increments the tolerated count for that time window by 1.  Any other states are ignored. Every dt seconds (as long as events are arriving), emits an event with a metric between 0 and 1, derived by:</p>
<p>(satisfied count + (tolerating count / 2) / total count of received events</p>
<p>Ignores expired events.</p>
<p>See <a href="http://en.wikipedia.org/wiki/Apdex">http://en.wikipedia.org/wiki/Apdex</a> for details.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L2105">view source</a></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append reference)</code></div><div class="doc"><div class="markdown"><p>Conj events onto the given reference</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1243">view source</a></div></div><div class="public anchor" id="var-batch"><h3>batch</h3><div class="usage"><code>(batch n dt &amp; children)</code></div><div class="doc"><div class="markdown"><p>Batches up events into vectors, bounded both by size and by time. Once either n events have accumulated, or dt seconds passed, flushes the current batch to all child streams. Child streams should accept a sequence of events.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1158">view source</a></div></div><div class="public anchor" id="var-bit-bucket"><h3>bit-bucket</h3><div class="usage"><code>(bit-bucket _)</code></div><div class="doc"><div class="markdown"><p>Discards arguments.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L121">view source</a></div></div><div class="public anchor" id="var-by"><h3>by</h3><h4 class="type">macro</h4><div class="usage"><code>(by fields &amp; children)</code></div><div class="doc"><div class="markdown"><p>Splits stream by field. Every time an event arrives with a new value of field, this macro invokes its child forms to return a <em>new</em>, distinct set of streams for that particular value.</p>
<p>(rate 5 prn) prints a single rate for all events, once every five seconds.</p>
<p>(by :host (rate 5) tracks a separate rate for <em>each host</em>, and prints each one every five seconds.</p>
<p>You can pass multiple fields too</p>
<p>(by <a href=":host :service">:host :service</a>)</p>
<p>Note that field can be a keyword like :host or :state, but you can <em>also</em> use any unary function for more complex sharding.</p>
<p>Be aware that (by) over unbounded values can result in <em>many</em> substreams being created, so you wouldn’t want to write (by metric prn): you’d get a separate prn for <em>every</em> unique metric that came in.  Also, (by) streams are never garbage-collected.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1556">view source</a></div></div><div class="public anchor" id="var-by-builder"><h3>by-builder</h3><h4 class="type">macro</h4><div class="usage"><code>(by-builder [sym fields] &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Splits stream by provided function. This is a variation of <code>by</code> where forms are executed when a fork is created to yield the children.</p>
<p>This allows you to perform operations based on the fork-name, i.e: the output of the given fields.</p>
<p>(by-builder <a href="forward" title="get relay-by-host host">host :host</a>)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1585">view source</a></div></div><div class="public anchor" id="var-by-fn"><h3>by-fn</h3><div class="usage"><code>(by-fn fields new-fork)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1599">view source</a></div></div><div class="public anchor" id="var-call-rescue"><h3>call-rescue</h3><h4 class="type">macro</h4><div class="usage"><code>(call-rescue event children)</code></div><div class="doc"><div class="markdown"><p>Call each child stream with event, in order. Rescues and logs any failure.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L61">view source</a></div></div><div class="public anchor" id="var-changed"><h3>changed</h3><div class="usage"><code>(changed pred &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on events only when (f event) differs from that of the previous event. Options:</p>
<ul>
<li>:init   The initial value to assume for (pred event).</li>
</ul>
<pre><code class="language-clojure">; Print all state changes
(changed :state prn)

; Assume states *were* ok the first time we see them.
(changed :state {:init "ok"} prn)

; Receive the previous event, in addition to the current event, as a vector.
(changed :state {:pairs? true}
         (fn [[event event']]
           (prn "changed from" (:state event) "to" (:state event'))))

; Note that f can be an arbitrary function:

(changed (fn [e] (&gt; (:metric e) 2)) ...)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1614">view source</a></div></div><div class="public anchor" id="var-changed-state"><h3>changed-state</h3><h4 class="type">macro</h4><div class="usage"><code>(changed-state &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on changes in state for each distinct host and service.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1655">view source</a></div></div><div class="public anchor" id="var-clock-skew"><h3>clock-skew</h3><div class="usage"><code>(clock-skew &amp; children)</code></div><div class="doc"><div class="markdown"><p>Detects clock skew between hosts. Keeps track of what time each host thinks it is, based on their most recent event time. Compares the time of each event to the median clock, and passes on that event with metric equal to the time difference: events ahead of the clock have positive metrics, and events behind the clock have negative metrics.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L2159">view source</a></div></div><div class="public anchor" id="var-coalesce"><h3>coalesce</h3><div class="usage"><code>(coalesce &amp; [dt &amp; children])</code></div><div class="doc"><div class="markdown"><p>Combines events over time. Coalesce remembers the most recent event for each service/host combination that passes through it (limited by :ttl). Every dt seconds (default to 1 second), it passes on <em>all</em> events it remembers. When events expire, they are included in the emitted sequence of events <em>once</em>, and removed from the state table thereafter.</p>
<p>Use coalesce to combine states that arrive at different times–for instance, to average the CPU use over several hosts.</p>
<p>Every 10 seconds, print a sequence of events including all the events which share the same :foo and :bar attributes:</p>
<pre><code class="language-clojure">(by [:foo :bar]
  (coalesce 10 prn))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1209">view source</a></div></div><div class="public anchor" id="var-coalesce-with-event"><h3>coalesce-with-event</h3><div class="usage"><code>(coalesce-with-event keyfn child)</code></div><div class="doc"><div class="markdown"><p>Helper for coalesce: calls (f current-event all-events) every time an event is received.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1187">view source</a></div></div><div class="public anchor" id="var-counter"><h3>counter</h3><div class="usage"><code>(counter &amp; children)</code></div><div class="doc"><div class="markdown"><p>Counts things. The first argument may be an initial counter value, which defaults to zero.</p>
<pre><code class="language-clojure">; Starts at zero
(counter index)

; Starts at 500
(counter 500 index)
</code></pre>
<p>Events without metrics are passed through unchanged. Events with metrics increment the counter, and are passed on with their metric set to the current count.</p>
<p>You can reset the counter by passing it an event with a metric, tagged “reset”; the count will be reset to that metric.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L900">view source</a></div></div><div class="public anchor" id="var-ddt"><h3>ddt</h3><div class="usage"><code>(ddt &amp; args)</code></div><div class="doc"><div class="markdown"><p>Differentiate metrics with respect to time. Takes an optional number followed by child streams. If the first argument is a number n, emits a rate-of-change event every n seconds, until expired. If the first argument is not number, emits an event for each event received, but with metric equal to the difference between the current event and the previous one, divided by the difference in their times. Skips events without metrics.</p>
<pre><code class="language-clojure">(ddt 5 graph index)
(ddt graph index)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L824">view source</a></div></div><div class="public anchor" id="var-ddt-events"><h3>ddt-events</h3><div class="usage"><code>(ddt-events &amp; children)</code></div><div class="doc"><div class="markdown"><p>(ddt) between each pair of events.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L809">view source</a></div></div><div class="public anchor" id="var-ddt-real"><h3>ddt-real</h3><div class="usage"><code>(ddt-real n &amp; children)</code></div><div class="doc"><div class="markdown"><p>(ddt) in real time.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L776">view source</a></div></div><div class="public anchor" id="var-default"><h3>default</h3><div class="usage"><code>(default &amp; args)</code></div><div class="doc"><div class="markdown"><p>Like <code>with</code>, but does not override existing (i.e. non-nil) values. Useful when you want to fill in default values for events that might come in without them.</p>
<pre><code class="language-clojure">(default :ttl 300 index)
(default {:service "jrecursive" :state "chicken"} index)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1393">view source</a></div></div><div class="public anchor" id="var-dual"><h3>dual</h3><div class="usage"><code>(dual pred true-stream false-stream)</code></div><div class="doc"><div class="markdown"><p>A stream which splits events into two mirror-images streams, based on (pred e).</p>
<p>If (pred e) is true, calls (true-stream e) and (false-stream (expire e)).</p>
<p>If (pred e) is false, does the opposite. Expired events are forwarded to both streams.</p>
<p>(pred e) is always called once per incoming event.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L125">view source</a></div></div><div class="public anchor" id="var-ewma"><h3>ewma</h3><div class="usage"><code>(ewma halflife &amp; children)</code></div><div class="doc"><div class="markdown"><p>Exponential weighted moving average. Constant space and time overhead. Passes on each event received, but with metric adjusted to the moving average. Takes into account the time between events.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L979">view source</a></div></div><div class="public anchor" id="var-ewma-timeless"><h3>ewma-timeless</h3><div class="usage"><code>(ewma-timeless r &amp; children)</code></div><div class="doc"><div class="markdown"><p>Exponential weighted moving average. Constant space and time overhead. Passes on each event received, but with metric adjusted to the moving average. Does not take the time between events into account. R is the ratio between successive events: r=1 means always return the most recent metric; r=1/2 means the current event counts for half, the previous event for 1/4, the previous event for 1/8, and so on.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L961">view source</a></div></div><div class="public anchor" id="var-exception-stream"><h3>exception-stream</h3><h4 class="type">macro</h4><div class="usage"><code>(exception-stream exception-stream &amp; children)</code></div><div class="doc"><div class="markdown"><p>Catches exceptions, converts them to events, and sends those events to a special exception stream.</p>
<pre><code class="language-clojure">(exception-stream (email "polito@vonbraun.com")
  (async-queue! :graphite {:core-pool-size 128}
    graph))
</code></pre>
<p>Streams often take multiple children and send an event to each using call-rescue. Call-rescue will rescue any exception thrown by a child stream, log it, and move on to the next child stream, so that a failure in one child won’t prevent others from executing.</p>
<p>Exceptions binds a dynamically scoped thread-local variable <em>exception-stream</em>. When call-rescue encounters an exception, it will <em>also</em> route the error to this exception stream. When switching threads (e.g. when using an executor or Thread), you must use (bound-fn) to preserve this binding.</p>
<p>This is a little more complex than you might think, because we <em>not only</em> need to bind this variable during the runtime execution of child streams, but <em>also</em> during the evaluation of the child streams themselves, e.g. at the invocation time of exceptions itself. If we write</p>
<pre><code class="language-clojure">(exception-stream (email ...)
  (rate 5 index))
</code></pre>
<p>then (rate), when invoked, might need access to this variable immediately. Therefore, this macro binds <em>exception-stream</em> twice: one when evaluating children, and again, every time the returned stream is invoked.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L79">view source</a></div></div><div class="public anchor" id="var-execute-on"><h3>execute-on</h3><div class="usage"><code>(execute-on executor &amp; children)</code></div><div class="doc"><div class="markdown"><p>Returns a stream which accepts events and executes them using a java.util.concurrent.Executor. Returns immediately. May throw RejectedExecutionException if the underlying executor will not accept the event; e.g. if its queue is full. Use together with riemann.service/executor-service for reloadable asynchronous execution of streams. See also: async-queue!, which may be simpler.</p>
<pre><code class="language-clojure">(let [io-pool (service!
                (executor-service
                  #(ThreadPoolExecutor. 1 10 ...)))
      graph (execute-on io-pool (graphite {:host ...}))]
  ...
  (tagged "graph"
    graph))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L267">view source</a></div></div><div class="public anchor" id="var-expired"><h3>expired</h3><div class="usage"><code>(expired &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on expired events.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1332">view source</a></div></div><div class="public anchor" id="var-expired.3F"><h3>expired?</h3><div class="usage"><code>(expired? event)</code></div><div class="doc"><div class="markdown"><p>There are two ways an event can be considered expired. First, if it has state “expired”. Second, if its :ttl and :time indicates it has expired.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L50">view source</a></div></div><div class="public anchor" id="var-fill-in"><h3>fill-in</h3><div class="usage"><code>(fill-in interval default-event &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on all events. Fills in gaps in event stream with copies of the given event, wherever interval seconds pass without an event arriving. Inserted events have current time. Stops inserting when expired. Uses local times.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L683">view source</a></div></div><div class="public anchor" id="var-fill-in-last"><h3>fill-in-last</h3><div class="usage"><code>(fill-in-last interval update &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on all events. Fills in gaps in event stream with copies of the last event merged with the given data, wherever interval seconds pass without an event arriving. Inserted events have current time. Stops inserting when expired. Uses local times.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L745">view source</a></div></div><div class="public anchor" id="var-fill-in-last*"><h3>fill-in-last*</h3><div class="usage"><code>(fill-in-last* interval updater &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on all events. Fills in gaps in event stream with copies of the last event updated with the given updater function, wherever interval seconds pass without an event arriving. Inserted events have current time. Stops inserting when expired. Uses local times.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L712">view source</a></div></div><div class="public anchor" id="var-fixed-event-window"><h3>fixed-event-window</h3><div class="usage"><code>(fixed-event-window n &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on fixed-size windows of n events each. Accumulates n events, then calls children with a vector of those events, from oldest to newest. Ignores event times. Example:</p>
<p>(fixed-event-window 5 (smap folds/mean index))</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L303">view source</a></div></div><div class="public anchor" id="var-fixed-offset-time-window"><h3>fixed-offset-time-window</h3><div class="usage"><code>(fixed-offset-time-window n &amp; children)</code></div><div class="doc"><div class="markdown"><p>Like fixed-time-window, but divides wall clock time into discrete windows.</p>
<p>A fixed window over the event stream in time. Emits vectors of events, such that each vector has events from a distinct n-second interval. Windows do <em>not</em> overlap; each event appears at most once in the output stream. Once an event is emitted, all events <em>older or equal</em> to that emitted event are silently dropped.</p>
<p>Events without times accrue in the current window.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L418">view source</a></div></div><div class="public anchor" id="var-fixed-time-window"><h3>fixed-time-window</h3><div class="usage"><code>(fixed-time-window n &amp; children)</code></div><div class="doc"><div class="markdown"><p>A fixed window over the event stream in time. Emits vectors of events, such that each vector has events from a distinct n-second interval. Windows do <em>not</em> overlap; each event appears at most once in the output stream. Once an event is emitted, all events <em>older or equal</em> to that emitted event are silently dropped.</p>
<p>Events without times accrue in the current window.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L407">view source</a></div></div><div class="public anchor" id="var-fold-interval"><h3>fold-interval</h3><div class="usage"><code>(fold-interval interval event-key folder &amp; children)</code></div><div class="doc"><div class="markdown"><p>Applies the folder function to all event-key values of events during interval seconds.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L663">view source</a></div></div><div class="public anchor" id="var-fold-interval-metric"><h3>fold-interval-metric</h3><div class="usage"><code>(fold-interval-metric interval folder &amp; children)</code></div><div class="doc"><div class="markdown"><p>Wrapping for fold-interval that assumes :metric as event-key.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L678">view source</a></div></div><div class="public anchor" id="var-forward"><h3>forward</h3><div class="usage"><code>(forward client)</code></div><div class="doc"><div class="markdown"><p>Sends an event or a collection of events through a Riemann client.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1255">view source</a></div></div><div class="public anchor" id="var-infinity"><h3>infinity</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L43">view source</a></div></div><div class="public anchor" id="var-interpolate-constant"><h3>interpolate-constant</h3><div class="usage"><code>(interpolate-constant interval &amp; children)</code></div><div class="doc"><div class="markdown"><p>Emits a constant stream of events every interval seconds, starting when an event is received, and ending when an expired event is received. Times are set to Riemann’s time. The first and last events are forwarded immediately.</p>
<p>Note: ignores event times currently–will change later.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L753">view source</a></div></div><div class="public anchor" id="var-match"><h3>match</h3><div class="usage"><code>(match f value &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes events on to children only when (f event) matches value, using riemann.common/match. For instance:</p>
<pre><code class="language-clojure">(match :service nil prn)
(match :state #{"warning" "critical"} prn)
(match :description #"error" prn)
(match :metric 5 prn)
(match expired? true prn)
(match (fn [e] (/ (:metric e) 1000)) 5 prn)
</code></pre>
<p>For cases where you only care about whether (f event) is truthy, use (where some-fn) instead of (match some-fn true).</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1263">view source</a></div></div><div class="public anchor" id="var-mean-over-time"><h3>mean-over-time</h3><div class="usage"><code>(mean-over-time children)</code></div><div class="doc"><div class="markdown"><p>Emits the most recent event each time this stream is called, but with the average of all received metrics.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L946">view source</a></div></div><div class="public anchor" id="var-moving-event-window"><h3>moving-event-window</h3><div class="usage"><code>(moving-event-window n &amp; children)</code></div><div class="doc"><div class="markdown"><p>A sliding window of the last few events. Every time an event arrives, calls children with a vector of the last n events, from oldest to newest. Ignores event times. Example:</p>
<p>(moving-event-window 5 (smap folds/mean index))</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L290">view source</a></div></div><div class="public anchor" id="var-moving-time-window"><h3>moving-time-window</h3><div class="usage"><code>(moving-time-window n &amp; children)</code></div><div class="doc"><div class="markdown"><p>A sliding window of all events with times within the last n seconds. Uses the maximum event time as the present-time horizon. Every time a new event arrives within the window, emits a vector of events in the window to children.</p>
<p>Events without times accrue in the current window.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L320">view source</a></div></div><div class="public anchor" id="var-not-expired"><h3>not-expired</h3><div class="usage"><code>(not-expired &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on not expired events.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1339">view source</a></div></div><div class="public anchor" id="var-over"><h3>over</h3><div class="usage"><code>(over x &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on events only when their metric is greater than x</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1661">view source</a></div></div><div class="public anchor" id="var-part-time-fast"><h3>part-time-fast</h3><div class="usage"><code>(part-time-fast interval create add finish)</code></div><div class="doc"><div class="markdown"><p>Partitions events by time (fast variant). Each <interval> seconds, creates a new bin by calling (create). Applies each received event to the current bin with (add bin event). When the time interval is over, calls (finish bin start-time elapsed-time).</interval></p>
<p>Concurrency guarantees:</p>
<ul>
<li>(create) may be called multiple times for a given time slice.</li>
<li>(add)    when called, will receive exactly one distinct bucket in each time slice.</li>
<li>(finish) will be called <em>exactly once</em> for each time slice.</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L543">view source</a></div></div><div class="public anchor" id="var-part-time-simple"><h3>part-time-simple</h3><div class="usage"><code>(part-time-simple dt reset add finish)</code><code>(part-time-simple dt reset add side-effects finish)</code></div><div class="doc"><div class="markdown"><p>Divides wall clock time into discrete windows. Returns a stream, composed of four functions:</p>
<p>(reset previous-state) Given the state for the previous window, returns a fresh state for a new window. Reset must be a pure function, as it will be invoked in a compare-and-set loop. Reset may be invoked at <em>any</em> time. Reset will be invoked with nil when no previous state exists.</p>
<p>(add state event) is called every time an event arrives to <em>combine</em> the event and the state together, returning some new state. Merge must be a pure function.</p>
<p>(side-effects state event) is called with the <em>resulting</em> state and the event which just arrived, but will be called only once per event, and can be impure. Its return value is used for the return value of the stream.</p>
<p>(finish state start-time end-time) is called once at the end of each time window, and receives the final state for that window, and also the start and end times for that window. Finish will be called exactly once per window, and may be impure.</p>
<p>When no events arrive in a given time window, no functions are called.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L595">view source</a></div></div><div class="public anchor" id="var-percentiles"><h3>percentiles</h3><div class="usage"><code>(percentiles interval points &amp; children)</code></div><div class="doc"><div class="markdown"><p>Over each period of interval seconds, aggregates events and selects one event from that period for each point. If point is 0, takes the lowest metric event.  If point is 1, takes the highest metric event. 0.5 is the median event, and so forth. Forwards each of these events to children. The service name has the point appended to it; e.g. ‘response time’ becomes ‘response time 0.95’.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L885">view source</a></div></div><div class="public anchor" id="var-periodically-until-expired"><h3>periodically-until-expired</h3><div class="usage"><code>(periodically-until-expired f)</code><code>(periodically-until-expired interval f)</code><code>(periodically-until-expired interval delay f)</code></div><div class="doc"><div class="markdown"><p>When an event arrives, begins calling f every interval seconds. Starts after delay. Stops calling f when an expired? event arrives, or the most recent event expires.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L499">view source</a></div></div><div class="public anchor" id="var-pipe"><h3>pipe</h3><h4 class="type">macro</h4><div class="usage"><code>(pipe marker &amp; stages)</code></div><div class="doc"><div class="markdown"><p>Sometimes, you want to have a stream split into several paths, then recombine those paths after some transformation. Pipe lets you write these topologies easily.</p>
<p>We might express a linear stream in Riemann, in which a -&gt; b -&gt; c -&gt; d, as</p>
<p>(a (b (c d)))</p>
<p>With pipe, we write</p>
<pre><code class="language-clojure">(pipe ↧ (a ↧)
        (b ↧)
        (c ↧)
        d)
</code></pre>
<p>The first argument ↧ is a <em>marker</em> for points where events should flow down into the next stage. A delightful list of marker symbols you might enjoy is available at <a href="http://www.alanwood.net/unicode/arrows.html">http://www.alanwood.net/unicode/arrows.html</a>.</p>
<p>What makes pipe more powerful than the standard Riemann composition rules is that the marker may appear <em>multiple times</em> in a stage, and <em>at any depth in the expression</em>. For instance, we might want to categorize events based on their metric, and send all those events into the same throttled email stream.</p>
<pre><code class="language-clojure">(let [throttled-emailer (throttle 100 1 (email "ops@rickenbacker.mil"))]
  (splitp &lt; metric
    0.9 (with :state :critical throttled-emailer)
    0.5 (with :state :warning  throttled-emailer)
        (with :state :ok       throttled-emailer)))
</code></pre>
<p>But with pipe, we can write:</p>
<pre><code class="language-clojure">(pipe - (splitp &lt; metric
                0.9 (with :state :critical -)
                0.5 (with :state :warning  -)
                    (with :state :ok       -))
        (throttle 100 1 (email "ops@rickenbacker.mil")))
</code></pre>
<p>So pipe lets us do three things:</p>
<ol>
<li>
<p><em>Flatten</em> a deeply nested expression, like Clojure’s -&gt; and -&gt;&gt;.</p>
</li>
<li>
<p><em>Omit or simplify</em> the names for each stage, when we care more about the <em>structure</em> of the streams than giving them full descriptions.</p>
</li>
<li>
<p>Write the stream in the <em>order in which events flow</em>.</p>
</li>
</ol>
<p>Pipe rewrites its stages as a let binding in reverse order; binding each stage to the placeholder in turn. The placeholder must be a compile-time symbol, and obeys the usual let-binding rules about variable shadowing; you can rebind the marker lexically within any stage using let, etc. Yep, this is a swiss arrow in disguise; ssshhhhhhh. ;-)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1490">view source</a></div></div><div class="public anchor" id="var-predict-linear"><h3>predict-linear</h3><div class="usage"><code>(predict-linear n s r &amp; children)</code></div><div class="doc"><div class="markdown"><p>Stream that performs OLS regression. Uses a moving-event-window of n events and emits an event with a prediction for :metric of s seconds in the future. If the optional model rebuild interval r (in seconds) is specified the model will be rebuild periodically and not on every arriving event.</p>
<p>E.g. predict the metric of service “fs-usage” 30 minutes in the future grouped by host:</p>
<pre><code class="language-clojure">(where (service "fs-usage")
  (by :host
    (predict-linear 100 1800
      #(info %))))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L2197">view source</a></div></div><div class="public anchor" id="var-project"><h3>project</h3><h4 class="type">macro</h4><div class="usage"><code>(project basis &amp; children)</code></div><div class="doc"><div class="markdown"><p>Projects an event stream into a specific basis–like (coalesce), but where you only want to compare two or three specific events. Takes a vector of predicate expressions, like those used in (where). Project maintains a vector of the most recent event for each predicate. An incoming event is compared against each predicate; if it matches, the event replaces any previous event in that position and the entire vector of events is forwarded to all child streams. Expired events are included in the emitted vector of events <em>once</em>, and removed from the state vector thereafter.</p>
<p>Use project when you want to compare a small number of distinct states over time. For instance, to find the ratio of enqueues to dequeues:</p>
<pre><code class="language-clojure">(project [(service "enqueues")
          (service "dequeues")]
  (smap folds/quotient
    (with :service "enqueues per dequeue"
      ...)))
</code></pre>
<p>Here we’ve combined separate events–enqueues and dequeues–into a single event, using the folds/quotient function, which divides the first event’s metric by the second. Then we assigned a new service name to that resulting event, and could subsequently filter based on the metric, assign different states, graph, alert, etc.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L2073">view source</a></div></div><div class="public anchor" id="var-project*"><h3>project*</h3><div class="usage"><code>(project* predicates &amp; children)</code></div><div class="doc"><div class="markdown"><p>Like project, but takes predicate <em>functions</em> instead of where expressions.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L2032">view source</a></div></div><div class="public anchor" id="var-rate"><h3>rate</h3><div class="usage"><code>(rate interval &amp; children)</code></div><div class="doc"><div class="markdown"><p>Take the sum of every event’s metric over interval seconds and divide by the interval size. Emits one event every interval seconds. Starts as soon as an event is received, stops when the most recent event expires. Uses the most recently received event with a metric as a template. Event ttls decrease constantly if no new events arrive.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L841">view source</a></div></div><div class="public anchor" id="var-register"><h3>register</h3><div class="usage"><code>(register reference)</code></div><div class="doc"><div class="markdown"><p>Set reference to the most recent event that passes through.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1249">view source</a></div></div><div class="public anchor" id="var-rollup"><h3>rollup</h3><div class="usage"><code>(rollup n dt &amp; children)</code></div><div class="doc"><div class="markdown"><p>Invokes children with events at most n times per dt second interval. Passes <em>vectors</em> of events to children, not a single event at a time. For instance, (rollup 3 1 f) receives five events and forwards three times per second:</p>
<ul>
<li>1 -&gt; (f <a href="1">1</a>)</li>
<li>2 -&gt; (f <a href="2">2</a>)</li>
<li>3 -&gt; (f <a href="3">3</a>)</li>
<li>4 -&gt;</li>
<li>5 -&gt;</li>
</ul>
<p>… and events 4 and 5 are rolled over into the next period:</p>
<p>-&gt; (f <a href="4 5">4 5</a>)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1120">view source</a></div></div><div class="public anchor" id="var-runs"><h3>runs</h3><div class="usage"><code>(runs len-run field &amp; children)</code></div><div class="doc"><div class="markdown"><p>Usable to perform flap detection, runs examines a moving-event-window of n events and determines if :field is the same across all them. If it is, runs passes on the last (newest) event of the window. In practice, this can be used with (changed-state …) as a child to reduce ‘flappiness’ for state changes.</p>
<p>(runs 3 :state prn) ; Print events where there are 3-in-a-row of a state.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1918">view source</a></div></div><div class="public anchor" id="var-scale"><h3>scale</h3><div class="usage"><code>(scale factor &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on a changed version of each event by multiplying each metric with the given scale factor.</p>
<p>; Convert bytes to kilobytes</p>
<p>(scale 1/1024 index)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1450">view source</a></div></div><div class="public anchor" id="var-sdo"><h3>sdo</h3><div class="usage"><code>(sdo)</code><code>(sdo child)</code><code>(sdo child &amp; children)</code></div><div class="doc"><div class="markdown"><p>Takes a list of functions f1, f2, f3, and returns f such that (f event) calls (f1 event) (f2 event) (f3 event). Useful for binding several streams to a single variable.</p>
<p>(sdo prn (rate 5 index))</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L250">view source</a></div></div><div class="public anchor" id="var-sflatten"><h3>sflatten</h3><div class="usage"><code>(sflatten &amp; children)</code></div><div class="doc"><div class="markdown"><p>Streaming flatten. Calls children with each event in events. Events should be a sequence.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L197">view source</a></div></div><div class="public anchor" id="var-smap"><h3>smap</h3><div class="usage"><code>(smap f &amp; children)</code></div><div class="doc"><div class="markdown"><p>Streaming map. Calls children with (f event), whenever (f event) is non-nil. Prefer this to (adjust f) and (combine f). Example:</p>
<pre><code class="language-clojure">(smap :metric prn) ; prints the metric of each event.
(smap #(assoc % :state "ok") index) ; Indexes each event with state "ok"
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L161">view source</a></div></div><div class="public anchor" id="var-smap*"><h3>smap*</h3><div class="usage"><code>(smap* f &amp; children)</code></div><div class="doc"><div class="markdown"><p>Streaming map: less magic. Calls children with (f event). Unlike smap, passes on nil results to children. Example:</p>
<p>(smap folds/maximum prn) ; Prints the maximum of lists of events.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L152">view source</a></div></div><div class="public anchor" id="var-smapcat"><h3>smapcat</h3><div class="usage"><code>(smapcat f &amp; children)</code></div><div class="doc"><div class="markdown"><p>Streaming mapcat. Calls children with each event in (f event), which should return a sequence. For instance, to set the state of any services with metrics deviating from the mode to “warning”, one might use coalesce to aggregate all services, and smapcat to find the mode and assoc the proper states; emitting a series of individual events to the index.</p>
<pre><code class="language-clojure">(coalesce
  (smapcat (fn [events]
             (let [freqs (frequencies (map :metric events))
                   mode  (apply max-key freqs (keys freqs))]
               (map #(assoc % :state (if (= mode (:metric %))
                                       "ok" "warning"))
                    events)))
    index))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L175">view source</a></div></div><div class="public anchor" id="var-split"><h3>split</h3><h4 class="type">macro</h4><div class="usage"><code>(split &amp; clauses)</code></div><div class="doc"><div class="markdown"><p>Behave as for split*, expecting predicates to be (where) expressions instead of functions. Example:</p>
<pre><code class="language-clojure">(split
  (&lt; 0.9  metric) (with :state "critical" index)
  (&lt; 0.75 metric) (with :state "warning" index)
  (with :state "ok" index))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1837">view source</a></div></div><div class="public anchor" id="var-split*"><h3>split*</h3><div class="usage"><code>(split* &amp; clauses)</code></div><div class="doc"><div class="markdown"><p>Given a list of function and stream pairs, passes the current event onto the stream associated with the first passing condition.</p>
<p>Conditions are functions as for where*.  An odd number of forms will make the last form the default stream. For example:</p>
<pre><code class="language-clojure"> (split*
   (fn [e] (&lt; 0.9  (:metric e))) (with :state "critical" index)
   (fn [e] (&lt; 0.75 (:metric e))) (with :state "warning" index)
   (with :state "ok" index))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1818">view source</a></div></div><div class="public anchor" id="var-split*-match"><h3>split*-match</h3><div class="usage"><code>(split*-match event [pred stream])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1812">view source</a></div></div><div class="public anchor" id="var-splitp"><h3>splitp</h3><h4 class="type">macro</h4><div class="usage"><code>(splitp pred expr &amp; clauses)</code></div><div class="doc"><div class="markdown"><p>Takes a binary predicate, an expression and a set of clauses. Each clause takes the form</p>
<p>test-expr stream</p>
<p>splitp returns a stream which accepts an event. Expr is a (where) expression, which will be evaluated against the event to obtain a value for selecting a clause. For each clause, evaluates (pred test-expr value). If the result is logical true, evaluates (stream event) and returns that value.</p>
<p>A single default stream can follow the clauses, and its value will be returned if no clause matches. If no default stream is provided and no clause matches, an IllegalArgumentException is thrown.</p>
<p>Splitp evaluates streams once at invocation time.</p>
<p>Example:</p>
<pre><code class="language-clojure">(splitp &lt; metric
  0.9  (with :state "critical" index)
  0.75 (with :state "warning" index)
       (with :state "ok" index))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1855">view source</a></div></div><div class="public anchor" id="var-sreduce"><h3>sreduce</h3><div class="usage"><code>(sreduce f &amp; opts)</code></div><div class="doc"><div class="markdown"><p>Streaming reduce. Two forms:</p>
<pre><code class="language-clojure">(sreduce f child1 child2 ...)
(sreduce f val child1 child2 ...)
</code></pre>
<p>Maintains an internal value, which defaults to the first event received or, if provided, val. When the stream receives an event, calls (f val event) to produce a new value, which is sent to each child. f <em>must</em> be free of side effects. Examples:</p>
<p>Passes on events, but with the <em>maximum</em> of all received metrics:</p>
<pre><code class="language-clojure">(sreduce (fn [acc event] (assoc event :metric
                                (max (:metric event) (:metric acc)))) ...)
</code></pre>
<p>Or, using riemann.folds, a simple moving average:</p>
<p>(sreduce (fn <a href="acc event">acc event</a>(folds/mean <a href="acc event">acc event</a>)) …)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L204">view source</a></div></div><div class="public anchor" id="var-stable"><h3>stable</h3><div class="usage"><code>(stable dt f &amp; children)</code></div><div class="doc"><div class="markdown"><p>A stream which detects stable groups of events over time. Takes a time period in seconds, and a function of events. Passes on all events for which (f event1) is equal to (f event2), for each successive pair of events, for at least dt seconds. Use (stable) to filter out transient spikes and flapping states.</p>
<p>In these plots, stable events are shown as =, and unstable events are shown as -. = events are passed to children, and - events are ignored.</p>
<pre><code>     A spike           Flapping           Stable changes
|                 |                    |
|       -         |    -- -   ======   |      =====
|                 |        -           |           ========
|======= ======   |====  -  --         |======
+-------------&gt;   +----------------&gt;   +------------------&gt;
      time              time                  time
</code></pre>
<p>May buffer events for up to dt seconds when the value of (f event) changes, in order to determine if the new value is stable or not.</p>
<pre><code class="language-clojure">; Passes on events where the state remains the same for at least five
; seconds.
(stable 5 :state prn)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1936">view source</a></div></div><div class="public anchor" id="var-stream"><h3>stream</h3><div class="usage"><code>(stream &amp; args)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L262">view source</a></div></div><div class="public anchor" id="var-sum-over-time"><h3>sum-over-time</h3><div class="usage"><code>(sum-over-time &amp; children)</code></div><div class="doc"><div class="markdown"><p>Sums all metrics together. Emits the most recent event each time this stream is called, but with summed metric.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L934">view source</a></div></div><div class="public anchor" id="var-tag"><h3>tag</h3><div class="usage"><code>(tag tags &amp; children)</code></div><div class="doc"><div class="markdown"><p>Adds a new tag, or set of tags, to events which flow through.</p>
<p>(tag “foo” index) (tag <a href="&quot;foo&quot; &quot;bar&quot;">“foo” “bar”</a> index)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1478">view source</a></div></div><div class="public anchor" id="var-tagged"><h3>tagged</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for tagged-all</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1330">view source</a></div></div><div class="public anchor" id="var-tagged-all"><h3>tagged-all</h3><div class="usage"><code>(tagged-all tags &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on events where all tags are present. This stream returns true if an event it receives matches those tags, nil otherwise.</p>
<p>Can be used as a predicate in a where form.</p>
<pre><code class="language-clojure">(tagged-all "foo" prn)
(tagged-all ["foo" "bar"] prn)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1290">view source</a></div></div><div class="public anchor" id="var-tagged-all.3F"><h3>tagged-all?</h3><div class="usage"><code>(tagged-all? tags event)</code></div><div class="doc"><div class="markdown"><p>Predicate function to check if a collection of tags is present in the tags of event.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1284">view source</a></div></div><div class="public anchor" id="var-tagged-any"><h3>tagged-any</h3><div class="usage"><code>(tagged-any tags &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on events where any of tags are present. This stream returns true if an event it receives matches those tags, nil otherwise.</p>
<p>Can be used as a predicate in a where form.</p>
<pre><code class="language-clojure">(tagged-any "foo" prn)
(tagged-any ["foo" "bar"] prn)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1313">view source</a></div></div><div class="public anchor" id="var-tagged-any.3F"><h3>tagged-any?</h3><div class="usage"><code>(tagged-any? tags event)</code></div><div class="doc"><div class="markdown"><p>Predicate function to check if any of a collection of tags are present in the tags of event.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1307">view source</a></div></div><div class="public anchor" id="var-throttle"><h3>throttle</h3><div class="usage"><code>(throttle n dt &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on at most n events, or vectors of events, every dt seconds. If more than n events (or vectors) arrive in a dt-second fixed window, drops remaining events. Imposes no additional latency; events are either passed on immediately or dropped.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1102">view source</a></div></div><div class="public anchor" id="var-top"><h3>top</h3><div class="usage"><code>(top k f top-stream)</code><code>(top k f top-stream bottom-stream)</code><code>(top k f top-stream bottom-stream demote?)</code></div><div class="doc"><div class="markdown"><p>Bifurcates a stream into a dual pair of streams: one for the top k events, and one for the bottom k events.</p>
<p>f is a function which maps events to comparable values, e.g. numbers. If an incoming event e falls in the top k, the top stream receives e and the bottom stream receives (expire e). If the event is <em>not</em> in the top k, calls (top (expire e)) and (bottom e).</p>
<p>If an inbound event is already expired, it is forwarded directly to both streams. In this way, both top- and bottom-stream have a consistent, dual view of the event space.</p>
<p>Index the top 10 events, by metric:</p>
<pre><code class="language-clojure">(top 10 :metric index)
</code></pre>
<p>Index everything, but tag the top k events with “top”:</p>
<pre><code class="language-clojure">(top 10 :metric
  (tag "top" index)
  index)
</code></pre>
<p>This implementation of top is lazy, in the sense that it won’t proactively expire events which are bumped from the top-k set–you have to wait for another event with the same host and service to arrive before child streams will know it’s expired.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1055">view source</a></div></div><div class="public anchor" id="var-under"><h3>under</h3><div class="usage"><code>(under x &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on events only when their metric is smaller than x</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1669">view source</a></div></div><div class="public anchor" id="var-untag"><h3>untag</h3><div class="usage"><code>(untag tags &amp; children)</code></div><div class="doc"><div class="markdown"><p>Removes a tag, or set of tags, from events which flow through.</p>
<p>(untag “foo” index) (untag <a href="&quot;foo&quot; &quot;bar&quot;">“foo” “bar”</a> index)</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1463">view source</a></div></div><div class="public anchor" id="var-where"><h3>where</h3><h4 class="type">macro</h4><div class="usage"><code>(where expr &amp; children)</code></div><div class="doc"><div class="markdown"><p>Passes on events where expr is true. Expr is rewritten using where-rewrite. ’event is bound to the event under consideration. Examples:</p>
<pre><code class="language-clojure">; Match any event where metric is either 1, 2, 3, or 4.
(where (metric 1 2 3 4) ...)

; Match a event where the metric is negative AND the state is ok.
(where (and (&gt; 0 metric)
            (state "ok")) ...)

; Match a event where the host begins with web
(where (host #"^web") ...)


; Match an event where the service is in a set of services
(where (service #{"service-foo" "service-bar"}) ...)
; which is equivalent to
(where (service "service-foo" "service-bar") ...)
</code></pre>
<p>If a child begins with (else …), the else’s body is executed when expr is false. For instance:</p>
<pre><code class="language-clojure">(where (service "www")
  (notify-www-team)
  (else
    (notify-misc-team)))
</code></pre>
<p>The streams generated by (where) return the value of expr: truthy if expr matched the given event, and falsey otherwise. This means (where (metric 5)) tests events and returns true if their metric is five.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1765">view source</a></div></div><div class="public anchor" id="var-where*"><h3>where*</h3><h4 class="type">macro</h4><div class="usage"><code>(where* f &amp; children)</code></div><div class="doc"><div class="markdown"><p>A simpler, less magical variant of (where). Instead of binding symbols in the context of an expression, where* takes a function which takes an event. When (f event) is truthy, passes event to children–and otherwise, passes event to (else …) children. For example:</p>
<pre><code class="language-clojure">(where* (fn [e] (&lt; 2 (:metric e))) prn)

(where* expired?
  (partial prn "Expired")
  (else
    (partial prn "Not expired!")))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1739">view source</a></div></div><div class="public anchor" id="var-where-partition-clauses"><h3>where-partition-clauses</h3><div class="usage"><code>(where-partition-clauses exprs)</code></div><div class="doc"><div class="markdown"><p>Given expressions like (a (else b) c (else d)), returns [<a href="a c">a c</a> <a href="b d">b d</a>]</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1728">view source</a></div></div><div class="public anchor" id="var-where-rewrite"><h3>where-rewrite</h3><div class="usage"><code>(where-rewrite expr)</code></div><div class="doc"><div class="markdown"><p>Rewrites lists recursively. Replaces (metric x y z) with a test matching (:metric event) to any of x, y, or z, either by = or re-find. Replaces any other instance of metric with (:metric event). Does the same for host, service, event, state, time, ttl, tags (which performs an exact match of the tag vector), tagged (which checks to see if the given tag is present at all), metric_f, and description.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1688">view source</a></div></div><div class="public anchor" id="var-window"><h3>window</h3><div class="usage"><code>(window n &amp; children)</code></div><div class="doc"><div class="markdown"><p>Alias for moving-event-window.</p>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L431">view source</a></div></div><div class="public anchor" id="var-with"><h3>with</h3><div class="usage"><code>(with &amp; args)</code></div><div class="doc"><div class="markdown"><p>Constructs a copy of each incoming event with new values for the given keys, and passes the resulting event on to each child stream. As everywhere in Riemann, events are immutable; only this stream’s children will see this version of the event.</p>
<p>If you only want to set <em>default</em> values, use <code>default</code>. If you want to update values for a key based on the <em>current value</em> of that field in each event, use <code>adjust</code>. If you want to update events using arbitrary functions, use <code>smap</code>.</p>
<pre><code class="language-clojure">; Print each event, but with service "foo"
(with :service "foo" prn)

; Print each event, but with no host and state "broken".
(with {:host nil :state "broken"} prn)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/riemann/riemann/blob/0.3.12/src/riemann/streams.clj#L1346">view source</a></div></div></div></body></html>