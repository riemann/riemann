<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>riemann.streams documentation</title></head><body><div id="header"><h1><a href="index.html">Riemann 0.2.6-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="riemann.bin.html"><span>riemann.bin</span></a></li><li><a href="riemann.campfire.html"><span>riemann.campfire</span></a></li><li><a href="riemann.common.html"><span>riemann.common</span></a></li><li><a href="riemann.config.html"><span>riemann.config</span></a></li><li><a href="riemann.core.html"><span>riemann.core</span></a></li><li><a href="riemann.deps.html"><span>riemann.deps</span></a></li><li><a href="riemann.email.html"><span>riemann.email</span></a></li><li><a href="riemann.folds.html"><span>riemann.folds</span></a></li><li><a href="riemann.graphite.html"><span>riemann.graphite</span></a></li><li><a href="riemann.hipchat.html"><span>riemann.hipchat</span></a></li><li><a href="riemann.index.html"><span>riemann.index</span></a></li><li><a href="riemann.influxdb.html"><span>riemann.influxdb</span></a></li><li><a href="riemann.instrumentation.html"><span>riemann.instrumentation</span></a></li><li><a href="riemann.kairosdb.html"><span>riemann.kairosdb</span></a></li><li><a href="riemann.librato.html"><span>riemann.librato</span></a></li><li><a href="riemann.logging.html"><span>riemann.logging</span></a></li><li><a href="riemann.logstash.html"><span>riemann.logstash</span></a></li><li><a href="riemann.nagios.html"><span>riemann.nagios</span></a></li><li><a href="riemann.opentsdb.html"><span>riemann.opentsdb</span></a></li><li><a href="riemann.pagerduty.html"><span>riemann.pagerduty</span></a></li><li><a href="riemann.plugin.html"><span>riemann.plugin</span></a></li><li><a href="riemann.pool.html"><span>riemann.pool</span></a></li><li><a href="riemann.pubsub.html"><span>riemann.pubsub</span></a></li><li><a href="riemann.query.html"><span>riemann.query</span></a></li><li><a href="riemann.repl.html"><span>riemann.repl</span></a></li><li><a href="riemann.service.html"><span>riemann.service</span></a></li><li><a href="riemann.slack.html"><span>riemann.slack</span></a></li><li><a href="riemann.sns.html"><span>riemann.sns</span></a></li><li class="current"><a href="riemann.streams.html"><span>riemann.streams</span></a></li><li><a href="riemann.time.html"><span>riemann.time</span></a></li><li><a href="riemann.time.controlled.html"><span>riemann.time.controlled</span></a></li><li><a href="riemann.transport.html"><span>riemann.transport</span></a></li><li><a href="riemann.transport.graphite.html"><span>riemann.transport.graphite</span></a></li><li><a href="riemann.transport.sse.html"><span>riemann.transport.sse</span></a></li><li><a href="riemann.transport.tcp.html"><span>riemann.transport.tcp</span></a></li><li><a href="riemann.transport.udp.html"><span>riemann.transport.udp</span></a></li><li><a href="riemann.transport.websockets.html"><span>riemann.transport.websockets</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="riemann.streams.html#var-*exception-stream*"><span>*exception-stream*</span></a></li><li><a href="riemann.streams.html#var--%3EApdexState"><span>-&gt;ApdexState</span></a></li><li><a href="riemann.streams.html#var-adjust"><span>adjust</span></a></li><li><a href="riemann.streams.html#var-apdex"><span>apdex</span></a></li><li><a href="riemann.streams.html#var-apdex*"><span>apdex*</span></a></li><li><a href="riemann.streams.html#var-append"><span>append</span></a></li><li><a href="riemann.streams.html#var-batch"><span>batch</span></a></li><li><a href="riemann.streams.html#var-bit-bucket"><span>bit-bucket</span></a></li><li><a href="riemann.streams.html#var-by"><span>by</span></a></li><li><a href="riemann.streams.html#var-call-rescue"><span>call-rescue</span></a></li><li><a href="riemann.streams.html#var-changed"><span>changed</span></a></li><li><a href="riemann.streams.html#var-changed-state"><span>changed-state</span></a></li><li><a href="riemann.streams.html#var-clock-skew"><span>clock-skew</span></a></li><li><a href="riemann.streams.html#var-coalesce"><span>coalesce</span></a></li><li><a href="riemann.streams.html#var-coalesce-with-event"><span>coalesce-with-event</span></a></li><li><a href="riemann.streams.html#var-combine"><span>combine</span></a></li><li><a href="riemann.streams.html#var-counter"><span>counter</span></a></li><li><a href="riemann.streams.html#var-ddt"><span>ddt</span></a></li><li><a href="riemann.streams.html#var-ddt-events"><span>ddt-events</span></a></li><li><a href="riemann.streams.html#var-ddt-real"><span>ddt-real</span></a></li><li><a href="riemann.streams.html#var-default"><span>default</span></a></li><li><a href="riemann.streams.html#var-dual"><span>dual</span></a></li><li><a href="riemann.streams.html#var-ewma"><span>ewma</span></a></li><li><a href="riemann.streams.html#var-ewma-timeless"><span>ewma-timeless</span></a></li><li><a href="riemann.streams.html#var-exception-stream"><span>exception-stream</span></a></li><li><a href="riemann.streams.html#var-execute-on"><span>execute-on</span></a></li><li><a href="riemann.streams.html#var-expired"><span>expired</span></a></li><li><a href="riemann.streams.html#var-expired%3F"><span>expired?</span></a></li><li><a href="riemann.streams.html#var-fill-in"><span>fill-in</span></a></li><li><a href="riemann.streams.html#var-fill-in-last"><span>fill-in-last</span></a></li><li><a href="riemann.streams.html#var-fixed-event-window"><span>fixed-event-window</span></a></li><li><a href="riemann.streams.html#var-fixed-time-window"><span>fixed-time-window</span></a></li><li><a href="riemann.streams.html#var-fold-interval"><span>fold-interval</span></a></li><li><a href="riemann.streams.html#var-fold-interval-metric"><span>fold-interval-metric</span></a></li><li><a href="riemann.streams.html#var-forward"><span>forward</span></a></li><li><a href="riemann.streams.html#var-interpolate-constant"><span>interpolate-constant</span></a></li><li><a href="riemann.streams.html#var-map-%3EApdexState"><span>map-&gt;ApdexState</span></a></li><li><a href="riemann.streams.html#var-match"><span>match</span></a></li><li><a href="riemann.streams.html#var-mean-over-time"><span>mean-over-time</span></a></li><li><a href="riemann.streams.html#var-moving-event-window"><span>moving-event-window</span></a></li><li><a href="riemann.streams.html#var-moving-time-window"><span>moving-time-window</span></a></li><li><a href="riemann.streams.html#var-over"><span>over</span></a></li><li><a href="riemann.streams.html#var-part-time-fast"><span>part-time-fast</span></a></li><li><a href="riemann.streams.html#var-part-time-simple"><span>part-time-simple</span></a></li><li><a href="riemann.streams.html#var-percentiles"><span>percentiles</span></a></li><li><a href="riemann.streams.html#var-periodically-until-expired"><span>periodically-until-expired</span></a></li><li><a href="riemann.streams.html#var-pipe"><span>pipe</span></a></li><li><a href="riemann.streams.html#var-project"><span>project</span></a></li><li><a href="riemann.streams.html#var-project*"><span>project*</span></a></li><li><a href="riemann.streams.html#var-rate"><span>rate</span></a></li><li><a href="riemann.streams.html#var-register"><span>register</span></a></li><li><a href="riemann.streams.html#var-rollup"><span>rollup</span></a></li><li><a href="riemann.streams.html#var-runs"><span>runs</span></a></li><li><a href="riemann.streams.html#var-scale"><span>scale</span></a></li><li><a href="riemann.streams.html#var-sdo"><span>sdo</span></a></li><li><a href="riemann.streams.html#var-smap"><span>smap</span></a></li><li><a href="riemann.streams.html#var-smap*"><span>smap*</span></a></li><li><a href="riemann.streams.html#var-smapcat"><span>smapcat</span></a></li><li><a href="riemann.streams.html#var-split"><span>split</span></a></li><li><a href="riemann.streams.html#var-split*"><span>split*</span></a></li><li><a href="riemann.streams.html#var-splitp"><span>splitp</span></a></li><li><a href="riemann.streams.html#var-sreduce"><span>sreduce</span></a></li><li><a href="riemann.streams.html#var-stable"><span>stable</span></a></li><li><a href="riemann.streams.html#var-sum-over-time"><span>sum-over-time</span></a></li><li><a href="riemann.streams.html#var-tag"><span>tag</span></a></li><li><a href="riemann.streams.html#var-tagged"><span>tagged</span></a></li><li><a href="riemann.streams.html#var-tagged-all"><span>tagged-all</span></a></li><li><a href="riemann.streams.html#var-tagged-all%3F"><span>tagged-all?</span></a></li><li><a href="riemann.streams.html#var-tagged-any"><span>tagged-any</span></a></li><li><a href="riemann.streams.html#var-tagged-any%3F"><span>tagged-any?</span></a></li><li><a href="riemann.streams.html#var-throttle"><span>throttle</span></a></li><li><a href="riemann.streams.html#var-top"><span>top</span></a></li><li><a href="riemann.streams.html#var-under"><span>under</span></a></li><li><a href="riemann.streams.html#var-where"><span>where</span></a></li><li><a href="riemann.streams.html#var-where*"><span>where*</span></a></li><li><a href="riemann.streams.html#var-where-partition-clauses"><span>where-partition-clauses</span></a></li><li><a href="riemann.streams.html#var-where-rewrite"><span>where-rewrite</span></a></li><li><a href="riemann.streams.html#var-window"><span>window</span></a></li><li><a href="riemann.streams.html#var-with"><span>with</span></a></li><li><a href="riemann.streams.html#var-within"><span>within</span></a></li><li><a href="riemann.streams.html#var-without"><span>without</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>riemann.streams documentation</h2><pre class="doc">The streams namespace aims to provide a comprehensive set of widely
applicable, combinable tools for building more complex streams.

Streams are functions which accept events or, in some cases, lists of events.

Streams typically do one or more of the following.

* Filter events.
* Transform events.
* Combine events over time.
* Apply events to other streams.
* Forward events to other services.

Most streams accept, after their initial arguments, any number of streams as
children. These are known as children or &quot;child streams&quot; of the stream.
The children are typically invoked sequentially, any exceptions thrown are
caught, logged and optionally forwarded to *exception-stream*.
Return values of children are ignored.

Events are backed by a map (e.g. {:service &quot;foo&quot; :metric 3.5}), so any
function that accepts maps will work with events.
Common functions like prn can be used as a child stream.

Some common patterns for defining child streams are (fn [e] (println e))
and (partial log :info).</pre><div class="public" id="var-*exception-stream*"><h3>*exception-stream*</h3><div class="usage"></div><pre class="doc">When an exception is caught, it's converted to an event and sent here.
</pre></div><div class="public" id="var--%3EApdexState"><h3>-&gt;ApdexState</h3><div class="usage"><code>(-&gt;ApdexState event satisfied tolerated other)</code></div><pre class="doc">Positional factory function for class riemann.streams.ApdexState.
</pre></div><div class="public" id="var-adjust"><h3>adjust</h3><div class="usage"><code>(adjust &amp; args)</code></div><pre class="doc">Passes on a changed version of each event by applying a function to a
particular field or to the event as a whole.

Passing a vector of [field function &amp; args] to adjust will modify the given
field in incoming events by applying the function to it along with the given
arguments.  For example:

(adjust [:service str &quot; rate&quot;] ...)

takes {:service &quot;foo&quot;} and emits {:service &quot;foo rate&quot;}.

If a function is passed to adjust instead of a vector, adjust behaves like
smap: the entire event will be given to the function and the result will be
passed along to the children. For example:

(adjust #(assoc % :metric (count (:tags %))) ...)

takes {:tags [&quot;foo&quot; &quot;bar&quot;]} and emits {:tags [&quot;foo&quot; &quot;bar&quot;] :metric 2}.

Prefer (smap f &amp; children) to (adjust f &amp; children) where possible.</pre></div><div class="public" id="var-apdex"><h3>apdex</h3><div class="usage"><code>(apdex dt satisfied? tolerated? &amp; children)</code></div><pre class="doc">A stream which computes Apdex metrics every dt seconds for a stream of
events. Satisfied? and tolerated? are predicates as for (where). If satisfied
is truthy, increments the satisfied count for that time window by 1. If
(tolerated? event) is truthy, increments the tolerated count for that time
window by 1. Any other states are ignored. Every dt seconds (as long as
events are arriving), emits an event with a metric between 0 and 1, derived
by:

(satisfied count + (tolerating count / 2) / total count of received events

Ignores expired events.

See http://en.wikipedia.org/wiki/Apdex for details.</pre></div><div class="public" id="var-apdex*"><h3>apdex*</h3><div class="usage"><code>(apdex* dt satisfied? tolerated? &amp; children)</code></div><pre class="doc">Like apdex, but takes functions of events rather than where-predicates.

A stream which computes Apdex metrics every dt seconds for a stream of
events. If (satisfied? event) is truthy, increments the satisfied count for
that time window by 1. If (tolerated? event) is truthy, increments the
tolerated count for that time window by 1.  Any other states are ignored.
Every dt seconds (as long as events are arriving), emits an event with a
metric between 0 and 1, derived by:

(satisfied count + (tolerating count / 2) / total count of received events

Ignores expired events.

See http://en.wikipedia.org/wiki/Apdex for details.</pre></div><div class="public" id="var-append"><h3>append</h3><div class="usage"><code>(append reference)</code></div><pre class="doc">Conj events onto the given reference
</pre></div><div class="public" id="var-batch"><h3>batch</h3><div class="usage"><code>(batch n dt &amp; children)</code></div><pre class="doc">Batches up events into vectors, bounded both by size and by time. Once
either n events have accumulated, or dt seconds passed, flushes the current
batch to all child streams. Child streams should accept a sequence of
events.</pre></div><div class="public" id="var-bit-bucket"><h3>bit-bucket</h3><div class="usage"><code>(bit-bucket args)</code></div><pre class="doc">Discards arguments.
</pre></div><div class="public" id="var-by"><h3>by</h3><div class="usage"><code>(by fields &amp; children)</code></div><pre class="doc">Splits stream by field.
Every time an event arrives with a new value of field, this macro invokes
its child forms to return a *new*, distinct set of streams for that
particular value.

(rate 5 prn) prints a single rate for all events, once every five seconds.

(by :host (rate 5) tracks a separate rate for *each host*, and prints each
one every five seconds.

You can pass multiple fields too

(by [:host :service])

Note that field can be a keyword like :host or :state, but you can *also* use
any unary function for more complex sharding.

Be aware that (by) over unbounded values can result in
*many* substreams being created, so you wouldn't want to write
(by metric prn): you'd get a separate prn for *every* unique metric that
came in.</pre></div><div class="public" id="var-call-rescue"><h3>call-rescue</h3><div class="usage"><code>(call-rescue event children)</code></div><pre class="doc">Call each child (children), in order, with event.
Rescues and logs any failure.</pre></div><div class="public" id="var-changed"><h3>changed</h3><div class="usage"><code>(changed pred &amp; children)</code></div><pre class="doc">Passes on events only when (f event) differs from that of the previous
event. Options:

:init   The initial value to assume for (pred event).

; Print all state changes
(changed :state prn)

; Assume states *were* ok the first time we see them.
(changed :state {:init &quot;ok&quot;} prn)

Note that f can be an arbitrary function:

(changed (fn [e] (&gt; (:metric e) 2)) ...)</pre></div><div class="public" id="var-changed-state"><h3>changed-state</h3><div class="usage"><code>(changed-state &amp; children)</code></div><pre class="doc">Passes on changes in state for each distinct host and service.
</pre></div><div class="public" id="var-clock-skew"><h3>clock-skew</h3><div class="usage"><code>(clock-skew &amp; children)</code></div><pre class="doc">Detects clock skew between hosts. Keeps track of what time each host thinks
it is, based on their most recent event time. Compares the time of each event
to the median clock, and passes on that event with metric equal to the time
difference: events ahead of the clock have positive metrics, and events
behind the clock have negative metrics.</pre></div><div class="public" id="var-coalesce"><h3>coalesce</h3><div class="usage"><code>(coalesce &amp; [dt &amp; children])</code></div><pre class="doc">Combines events over time. Coalesce remembers the most recent event for each
service/host combination that passes through it (limited by :ttl). Every dt
seconds (default to 1 second), it passes on *all* events it remembers. When
events expire, they are included in the emitted sequence of events *once*,
and removed from the state table thereafter.

Use coalesce to combine states that arrive at different times--for instance,
to average the CPU use over several hosts.

Every 10 seconds, print a sequence of events including all the events which
share the same :foo and :bar attributes:

(by [:foo :bar]
  (coalesce 10 prn))</pre></div><div class="public" id="var-coalesce-with-event"><h3>coalesce-with-event</h3><div class="usage"><code>(coalesce-with-event keyfn child)</code></div><pre class="doc">Helper for coalesce: calls (f current-event all-events) every time an event
is received.</pre></div><div class="public" id="var-combine"><h3>combine</h3><div class="usage"><code>(combine f &amp; children)</code></div><pre class="doc">Returns a function which takes a seq of events.
Combines events with f, then forwards the result to children.</pre></div><div class="public" id="var-counter"><h3>counter</h3><div class="usage"><code>(counter &amp; children)</code></div><pre class="doc">Counts things. The first argument may be an initial counter value, which
defaults to zero.

; Starts at zero
(counter index)

; Starts at 500
(counter 500 index)

Events without metrics are passed through unchanged. Events with metrics
increment the counter, and are passed on with their metric set to the current
count.

You can reset the counter by passing it an event with a metric, tagged
&quot;reset&quot;; the count will be reset to that metric.</pre></div><div class="public" id="var-ddt"><h3>ddt</h3><div class="usage"><code>(ddt &amp; args)</code></div><pre class="doc">Differentiate metrics with respect to time. With no args, emits an event for
each one received, but with metric equal to the difference between the
current event and the previous one, divided by the difference in their times.
If the first argument is a number n, emits a rate-of-change event every n
seconds instead, until expired. Skips events without metrics.</pre></div><div class="public" id="var-ddt-events"><h3>ddt-events</h3><div class="usage"><code>(ddt-events &amp; children)</code></div><pre class="doc">(ddt) between each pair of events.
</pre></div><div class="public" id="var-ddt-real"><h3>ddt-real</h3><div class="usage"><code>(ddt-real n &amp; children)</code></div><pre class="doc">(ddt) in real time.
</pre></div><div class="public" id="var-default"><h3>default</h3><div class="usage"><code>(default &amp; args)</code></div><pre class="doc">Like `with`, but does not override existing (i.e. non-nil) values. Useful
when you want to fill in default values for events that might come in without
them.

(default :ttl 300 index)
(default {:service &quot;jrecursive&quot; :state &quot;chicken&quot;} index)</pre></div><div class="public" id="var-dual"><h3>dual</h3><div class="usage"><code>(dual pred true-stream false-stream)</code></div><pre class="doc">A stream which splits events into two mirror-images streams, based on
(pred e).
If (pred e) is true, calls (true-stream e) and (false-stream (expire e)).
If (pred e) is false, does the opposite. Expired events are forwarded to both
streams.

(pred e) is always called once per incoming event.</pre></div><div class="public" id="var-ewma"><h3>ewma</h3><div class="usage"><code>(ewma halflife &amp; children)</code></div><pre class="doc">Exponential weighted moving average. Constant space and time overhead.
Passes on each event received, but with metric adjusted to the moving
average. Takes into account the time between events.</pre></div><div class="public" id="var-ewma-timeless"><h3>ewma-timeless</h3><div class="usage"><code>(ewma-timeless r &amp; children)</code></div><pre class="doc">Exponential weighted moving average. Constant space and time overhead.
Passes on each event received, but with metric adjusted to the moving
average. Does not take the time between events into account. R is the ratio
between successive events: r=1 means always return the most recent metric;
r=1/2 means the current event counts for half, the previous event for 1/4,
the previous event for 1/8, and so on.</pre></div><div class="public" id="var-exception-stream"><h3>exception-stream</h3><div class="usage"><code>(exception-stream exception-stream &amp; children)</code></div><pre class="doc">Catches exceptions, converts them to events, and sends those events to a
special exception stream.

(exception-stream (email &quot;polito@vonbraun.com&quot;)
  (async-queue! :graphite {:core-pool-size 128}
    graph))

Streams often take multiple children and send an event to each using
call-rescue. Call-rescue will rescue any exception thrown by a child stream,
log it, and move on to the next child stream, so that a failure in one child
won't prevent others from executing.

Exceptions binds a dynamically scoped thread-local variable
*exception-stream*. When call-rescue encounters an exception, it will *also*
route the error to this exception stream. When switching threads (e.g. when
using an executor or Thread), you
must use (bound-fn) to preserve this binding.

This is a little more complex than you might think, because we *not only*
need to bind this variable during the runtime execution of child streams, but
*also* during the evaluation of the child streams themselves, e.g. at the
invocation time of exceptions itself. If we write

(exception-stream (email ...)
  (rate 5 index))

then (rate), when invoked, might need access to this variable immediately.
Therefore, this macro binds *exception-stream* twice: one when evaluating
children, and again, every time the returned stream is invoked.</pre></div><div class="public" id="var-execute-on"><h3>execute-on</h3><div class="usage"><code>(execute-on executor &amp; children)</code></div><pre class="doc">Returns a stream which accepts events and executes them using a
java.util.concurrent.Executor. Returns immediately. May throw
RejectedExecutionException if the underlying executor will not accept the
event; e.g. if its queue is full. Use together with
riemann.service/executor-service for reloadable asynchronous execution of
streams. See also: async-queue!, which may be simpler.

(let [io-pool (service!
                (executor-service
                  #(ThreadPoolExecutor. 1 10 ...)))
      graph (execute-on io-pool (graphite {:host ...}))]
  ...
  (tagged &quot;graph&quot;
    graph))</pre></div><div class="public" id="var-expired"><h3>expired</h3><div class="usage"><code>(expired &amp; children)</code></div><pre class="doc">Passes on events with :state &quot;expired&quot;.
</pre></div><div class="public" id="var-expired%3F"><h3>expired?</h3><div class="usage"><code>(expired? event)</code></div><pre class="doc">There are two ways an event can be considered expired.
First, if it has state &quot;expired&quot;.
Second, if its :ttl and :time indicates it has expired.</pre></div><div class="public" id="var-fill-in"><h3>fill-in</h3><div class="usage"><code>(fill-in interval default-event &amp; children)</code></div><pre class="doc">Passes on all events. Fills in gaps in event stream with copies of the given
event, wherever interval seconds pass without an event arriving. Inserted
events have current time. Stops inserting when expired. Uses local times.</pre></div><div class="public" id="var-fill-in-last"><h3>fill-in-last</h3><div class="usage"><code>(fill-in-last interval update &amp; children)</code></div><pre class="doc">Passes on all events. Fills in gaps in event stream with copies of the last
event merged with the given data, wherever interval seconds pass without an
event arriving. Inserted events have current time. Stops inserting when
expired. Uses local times.</pre></div><div class="public" id="var-fixed-event-window"><h3>fixed-event-window</h3><div class="usage"><code>(fixed-event-window n &amp; children)</code></div><pre class="doc">Passes on fixed-size windows of n events each. Accumulates n events, then
calls children with a vector of those events, from oldest to newest. Ignores
event times. Example:

(fixed-event-window 5 (smap folds/mean index))</pre></div><div class="public" id="var-fixed-time-window"><h3>fixed-time-window</h3><div class="usage"><code>(fixed-time-window n &amp; children)</code></div><pre class="doc">A fixed window over the event stream in time. Emits vectors of events, such
that each vector has events from a distinct n-second interval. Windows do
*not* overlap; each event appears at most once in the output stream. Once an
event is emitted, all events *older or equal* to that emitted event are
silently dropped.

Events without times accrue in the current window.</pre></div><div class="public" id="var-fold-interval"><h3>fold-interval</h3><div class="usage"><code>(fold-interval interval event-key folder &amp; children)</code></div><pre class="doc">Applies the folder function to all event-key values of events during
interval seconds.</pre></div><div class="public" id="var-fold-interval-metric"><h3>fold-interval-metric</h3><div class="usage"><code>(fold-interval-metric interval folder &amp; children)</code></div><pre class="doc">Wrapping for fold-interval that assumes :metric as event-key.
</pre></div><div class="public" id="var-forward"><h3>forward</h3><div class="usage"><code>(forward client)</code></div><pre class="doc">Sends an event or a collection of events through a Riemann client.
</pre></div><div class="public" id="var-interpolate-constant"><h3>interpolate-constant</h3><div class="usage"><code>(interpolate-constant interval &amp; children)</code></div><pre class="doc">Emits a constant stream of events every interval seconds, starting when an
event is received, and ending when an expired event is received. Times are
set to Riemann's time. The first and last events are forwarded immediately.

Note: ignores event times currently--will change later.</pre></div><div class="public" id="var-map-%3EApdexState"><h3>map-&gt;ApdexState</h3><div class="usage"><code>(map-&gt;ApdexState m__5869__auto__)</code></div><pre class="doc">Factory function for class riemann.streams.ApdexState, taking a map of keywords to field values.
</pre></div><div class="public" id="var-match"><h3>match</h3><div class="usage"><code>(match f value &amp; children)</code></div><pre class="doc">Passes events on to children only when (f event) matches value, using
riemann.common/match. For instance:

(match :service nil prn)
(match :state #{&quot;warning&quot; &quot;critical&quot;} prn)
(match :description #&quot;error&quot; prn)
(match :metric 5 prn)
(match expired? true prn)
(match (fn [e] (/ (:metric e) 1000)) 5 prn)

For cases where you only care about whether (f event) is truthy, use (where
some-fn) instead of (match some-fn true).</pre></div><div class="public" id="var-mean-over-time"><h3>mean-over-time</h3><div class="usage"><code>(mean-over-time children)</code></div><pre class="doc">Emits the most recent event each time this stream is called, but with the
average of all received metrics.</pre></div><div class="public" id="var-moving-event-window"><h3>moving-event-window</h3><div class="usage"><code>(moving-event-window n &amp; children)</code></div><pre class="doc">A sliding window of the last few events. Every time an event arrives, calls
children with a vector of the last n events, from oldest to newest. Ignores
event times. Example:

(moving-event-window 5 (smap folds/mean index))</pre></div><div class="public" id="var-moving-time-window"><h3>moving-time-window</h3><div class="usage"><code>(moving-time-window n &amp; children)</code></div><pre class="doc">A sliding window of all events with times within the last n seconds. Uses
the maximum event time as the present-time horizon. Every time a new event
arrives within the window, emits a vector of events in the window to
children.

Events without times accrue in the current window.</pre></div><div class="public" id="var-over"><h3>over</h3><div class="usage"><code>(over x &amp; children)</code></div><pre class="doc">Passes on events only when their metric is greater than x
</pre></div><div class="public" id="var-part-time-fast"><h3>part-time-fast</h3><div class="usage"><code>(part-time-fast interval create add finish)</code></div><pre class="doc">Partitions events by time (fast variant). Each &lt;interval&gt; seconds, creates a
new bin by calling (create). Applies each received event to the current bin
with (add bin event). When the time interval is over, calls (finish bin
start-time elapsed-time).

Concurrency guarantees:

(create) may be called multiple times for a given time slice.
(add)    when called, will receive exactly one distinct bucket in each time
         slice.
(finish) will be called *exactly once* for each time slice.</pre></div><div class="public" id="var-part-time-simple"><h3>part-time-simple</h3><div class="usage"><code>(part-time-simple dt reset add finish)</code><code>(part-time-simple dt reset add side-effects finish)</code></div><pre class="doc">Divides wall clock time into discrete windows. Returns a stream, composed
of four functions:

(reset previous-state) Given the state for the previous window, returns a
fresh state for a new window. Reset must be a pure function, as it will be
invoked in a compare-and-set loop. Reset may be invoked at *any* time. Reset
will be invoked with nil when no previous state exists.

(add state event) is called every time an event arrives to *combine* the
event and the state together, returning some new state. Merge must be a pure
function.

(side-effects state event) is called with the *resulting* state and the event
which just arrived, but will be called only once per event, and can be
impure. Its return value is used for the return value of the stream.

(finish state start-time end-time) is called once at the end of each time
window, and receives the final state for that window, and also the start
and end times for that window. Finish will be called exactly once per window,
and may be impure.

When no events arrive in a given time window, no functions are called.</pre></div><div class="public" id="var-percentiles"><h3>percentiles</h3><div class="usage"><code>(percentiles interval points &amp; children)</code></div><pre class="doc">Over each period of interval seconds, aggregates events and selects one
event from that period for each point. If point is 0, takes the lowest metric
event.  If point is 1, takes the highest metric event. 0.5 is the median
event, and so forth. Forwards each of these events to children. The service
name has the point appended to it; e.g. 'response time' becomes 'response
time .95'.</pre></div><div class="public" id="var-periodically-until-expired"><h3>periodically-until-expired</h3><div class="usage"><code>(periodically-until-expired f)</code><code>(periodically-until-expired interval f)</code><code>(periodically-until-expired interval delay f)</code></div><pre class="doc">When an event arrives, begins calling f every interval seconds. Starts after
delay. Stops calling f when an expired? event arrives, or the most recent
event expires.</pre></div><div class="public" id="var-pipe"><h3>pipe</h3><div class="usage"><code>(pipe marker &amp; stages)</code></div><pre class="doc">Sometimes, you want to have a stream split into several paths, then
recombine those paths after some transformation. Pipe lets you write
these topologies easily.

We might express a linear stream in Riemann, in which a -&gt; b -&gt; c -&gt; d, as

(a (b (c d)))

With pipe, we write

(pipe ↧ (a ↧)
        (b ↧)
        (c ↧)
        d)

The first argument ↧ is a *marker* for points where events should flow down
into the next stage. A delightful list of marker symbols you might enjoy is
available at http://www.alanwood.net/unicode/arrows.html.

What makes pipe more powerful than the standard Riemann composition rules is
that the marker may appear *multiple times* in a stage, and *at any depth in
the expression*. For instance, we might want to categorize events based on
their metric, and send all those events into the same throttled email stream.

(let [throttled-emailer (throttle 100 1 (email &quot;ops@rickenbacker.mil&quot;))]
  (splitp &lt; metric
    0.9 (with :state :critical throttled-emailer)
    0.5 (with :state :warning  throttled-emailer)
        (with :state :ok       throttled-emailer)))

But with pipe, we can write:

(pipe - (splitp &lt; metric
                0.9 (with :state :critical -)
                0.5 (with :state :warning  -)
                    (with :state :ok       -))
        (throttle 100 1 (email &quot;ops@rickenbacker.mil&quot;)))

So pipe lets us do three things:

0. *Flatten* a deeply nested expression, like Clojure's -&gt; and -&gt;&gt;.

1. *Omit or simplify* the names for each stage, when we care more about the
*structure* of the streams than giving them full descriptions.

2. Write the stream in the *order in which events flow*.

Pipe rewrites its stages as a let binding in reverse order; binding each
stage to the placeholder in turn. The placeholder must be a compile-time
symbol, and obeys the usual let-binding rules about variable shadowing; you
can rebind the marker lexically within any stage using let, etc. Yep, this is
a swiss arrow in disguise; ssshhhhhhh. ;-)</pre></div><div class="public" id="var-project"><h3>project</h3><div class="usage"><code>(project basis &amp; children)</code></div><pre class="doc">Projects an event stream into a specific basis--like (coalesce), but where
you only want to compare two or three specific events. Takes a vector of
predicate expressions, like those used in (where). Project maintains a vector
of the most recent event for each predicate. An incoming event is compared
against each predicate; if it matches, the event replaces any previous event
in that position and the entire vector of events is forwarded to all child
streams. Expired events are included in the emitted vector of events *once*,
and removed from the state vector thereafter.

Use project when you want to compare a small number of distinct states over
time. For instance, to find the ratio of enqueues to dequeues:

(project [(service &quot;enqueues&quot;)
          (service &quot;dequeues&quot;)]
  (fn [[enq deq]]
    (prn (/ (:metric enq)
            (:metric deq)))))</pre></div><div class="public" id="var-project*"><h3>project*</h3><div class="usage"><code>(project* predicates &amp; children)</code></div><pre class="doc">Like project, but takes predicate *functions* instead of where expressions.
</pre></div><div class="public" id="var-rate"><h3>rate</h3><div class="usage"><code>(rate interval &amp; children)</code></div><pre class="doc">Take the sum of every event's metric over interval seconds and divide by the
interval size. Emits one event every interval seconds. Starts as soon as an
event is received, stops when an expired event arrives. Uses the most
recently received event with a metric as a template. Event ttls decrease
constantly if no new events arrive.</pre></div><div class="public" id="var-register"><h3>register</h3><div class="usage"><code>(register reference)</code></div><pre class="doc">Set reference to the most recent event that passes through.
</pre></div><div class="public" id="var-rollup"><h3>rollup</h3><div class="usage"><code>(rollup n dt &amp; children)</code></div><pre class="doc">Invokes children with events at most n times per dt second interval. Passes
*vectors* of events to children, not a single event at a time. For instance,
(rollup 3 1 f) receives five events and forwards three times per second:

1 -&gt; (f [1])
2 -&gt; (f [2])
3 -&gt; (f [3])
4 -&gt;
5 -&gt;

... and events 4 and 5 are rolled over into the next period:

  -&gt; (f [4 5])</pre></div><div class="public" id="var-runs"><h3>runs</h3><div class="usage"><code>(runs len-run field &amp; children)</code></div><pre class="doc">Usable to perform flap detection, runs examines a moving-event-window of
n events and determines if :field is the same across all them. If it is,
runs passes on the last (newest) event of the window. In practice, this can
be used with (changed-state ...) as a child to reduce 'flappiness' for state
changes.

(runs 3 :state prn) ; Print events where there are 3-in-a-row of a state.</pre></div><div class="public" id="var-scale"><h3>scale</h3><div class="usage"><code>(scale factor &amp; children)</code></div><pre class="doc">Passes on a changed version of each event by multiplying each
 metric with the given scale factor.

; Convert bytes to kilobytes
(scale 1/1024 index)</pre></div><div class="public" id="var-sdo"><h3>sdo</h3><div class="usage"><code>(sdo &amp; children)</code></div><pre class="doc">Takes a list of functions f1, f2, f3, and returns f such that (f event)
calls (f1 event) (f2 event) (f3 event). Useful for binding several streams to
a single variable.

(sdo prn (rate 5 index))</pre></div><div class="public" id="var-smap"><h3>smap</h3><div class="usage"><code>(smap f &amp; children)</code></div><pre class="doc">Streaming map. Calls children with (f event), whenever (f event) is non-nil.
Prefer this to (adjust f) and (combine f). Example:

(smap :metric prn) ; prints the metric of each event.
(smap #(assoc % :state &quot;ok&quot;) index) ; Indexes each event with state &quot;ok&quot;</pre></div><div class="public" id="var-smap*"><h3>smap*</h3><div class="usage"><code>(smap* f &amp; children)</code></div><pre class="doc">Streaming map: less magic. Calls children with (f event).
Unlike smap, passes on nil results to children. Example:

(smap folds/maximum prn) ; Prints the maximum of lists of events.</pre></div><div class="public" id="var-smapcat"><h3>smapcat</h3><div class="usage"><code>(smapcat f &amp; children)</code></div><pre class="doc">Streaming mapcat. Calls children with each event in (f event), which should
return a sequence. For instance, to set the state of any services with
metrics deviating from the mode to &quot;warning&quot;, one might use coalesce to
aggregate all services, and smapcat to find the mode and assoc the proper
states; emitting a series of individual events to the index.

(coalesce
  (smapcat (fn [events]
             (let [freqs (frequencies (map :metric events))
                   mode  (apply max-key freqs (keys freqs))]
               (map #(assoc % :state (if (= mode (:metric %))
                                       &quot;ok&quot; &quot;warning&quot;))
                    events)))
    index))</pre></div><div class="public" id="var-split"><h3>split</h3><div class="usage"><code>(split &amp; clauses)</code></div><pre class="doc">Behave as for split*, expecting predicates to be (where) expressions instead
of functions. Example:

(split
  (&lt; 0.9  metric) (with :state &quot;critical&quot; index)
  (&lt; 0.75 metric) (with :state &quot;warning&quot; index)
  (with :state &quot;ok&quot; index))</pre></div><div class="public" id="var-split*"><h3>split*</h3><div class="usage"><code>(split* &amp; clauses)</code></div><pre class="doc">Given a list of function and stream pairs, passes the current event onto the
stream associated with the first passing condition.

 Conditions are functions as for where*.  An odd number of forms will make
the last form the default stream. For example:

 (split*
   (fn [e] (&lt; 0.9  (:metric e))) (with :state &quot;critical&quot; index)
   (fn [e] (&lt; 0.75 (:metric e))) (with :state &quot;warning&quot; index)
   (with :state &quot;ok&quot; index))</pre></div><div class="public" id="var-splitp"><h3>splitp</h3><div class="usage"><code>(splitp pred expr &amp; clauses)</code></div><pre class="doc">Takes a binary predicate, an expression and a set of clauses. Each clause
takes the form

test-expr stream

splitp returns a stream which accepts an event. Expr is a (where) expression,
which will be evaluated against the event to obtain a value for selecting a
clause. For each clause, evaluates (pred test-expr value). If the result is
logical true, evaluates (stream event) and returns that value.

A single default stream can follow the clauses, and its value will be
returned if no clause matches. If no default stream is provided and no clause
matches, an IllegalArgumentException is thrown.

Splitp evaluates streams once at invocation time.

Example:

(splitp &lt; metric
  0.9  (with :state &quot;critical&quot; index)
  0.75 (with :state &quot;warning&quot; index)
       (with :state &quot;ok&quot; index))</pre></div><div class="public" id="var-sreduce"><h3>sreduce</h3><div class="usage"><code>(sreduce f &amp; opts)</code></div><pre class="doc">Streaming reduce. Two forms:

(sreduce f child1 child2 ...)
(sreduce f val child1 child2 ...)

Maintains an internal value, which defaults to the first event received or,
if provided, val. When the stream receives an event, calls (f val event) to
produce a new value, which is sent to each child. f *must* be free of side
effects. Examples:

Passes on events, but with the *maximum* of all received metrics:
(sreduce (fn [acc event] (assoc event :metric
                                (max (:metric event) (:metric acc)))) ...)

Or, using riemann.folds, a simple moving average:
(sreduce (fn [acc event] (folds/mean [acc event])) ...)</pre></div><div class="public" id="var-stable"><h3>stable</h3><div class="usage"><code>(stable dt f &amp; children)</code></div><pre class="doc">A stream which detects stable groups of events over time. Takes a time
period in seconds, and a function of events. Passes on all events for which
(f event1) is equal to (f event2), for each successive pair of events, for at
least dt seconds. Use (stable) to filter out transient spikes and flapping
states.

In these plots, stable events are shown as =, and unstable events are shown
as -. = events are passed to children, and - events are ignored.

     A spike           Flapping           Stable changes
|                 |                    |
|       -         |    -- -   ======   |      =====
|                 |        -           |           ========
|======= ======   |====  -  --         |======
+-------------&gt;   +----------------&gt;   +------------------&gt;
      time              time                  time

May buffer events for up to dt seconds when the value of (f event) changes,
in order to determine if the new value is stable or not.

; Passes on events where the state remains the same for at least five
; seconds.
(stable 5 :state prn)</pre></div><div class="public" id="var-sum-over-time"><h3>sum-over-time</h3><div class="usage"><code>(sum-over-time &amp; children)</code></div><pre class="doc">Sums all metrics together. Emits the most recent event each time this
stream is called, but with summed metric.</pre></div><div class="public" id="var-tag"><h3>tag</h3><div class="usage"><code>(tag tags &amp; children)</code></div><pre class="doc">Adds a new tag, or set of tags, to events which flow through.

(tag &quot;foo&quot; index)
(tag [&quot;foo&quot; &quot;bar&quot;] index)</pre></div><div class="public" id="var-tagged"><h3>tagged</h3><div class="usage"></div><pre class="doc">Alias for tagged-all
</pre></div><div class="public" id="var-tagged-all"><h3>tagged-all</h3><div class="usage"><code>(tagged-all tags &amp; children)</code></div><pre class="doc">Passes on events where all tags are present. This stream returns true if an
event it receives matches those tags, nil otherwise.

Can be used as a predicate in a where form.

(tagged-all &quot;foo&quot; prn)
(tagged-all [&quot;foo&quot; &quot;bar&quot;] prn)</pre></div><div class="public" id="var-tagged-all%3F"><h3>tagged-all?</h3><div class="usage"><code>(tagged-all? tags event)</code></div><pre class="doc">Predicate function to check if a collection of tags is
present in the tags of event.</pre></div><div class="public" id="var-tagged-any"><h3>tagged-any</h3><div class="usage"><code>(tagged-any tags &amp; children)</code></div><pre class="doc">Passes on events where any of tags are present. This stream returns true if
an event it receives matches those tags, nil otherwise.

Can be used as a predicate in a where form.

(tagged-any &quot;foo&quot; prn)
(tagged-all [&quot;foo&quot; &quot;bar&quot;] prn)</pre></div><div class="public" id="var-tagged-any%3F"><h3>tagged-any?</h3><div class="usage"><code>(tagged-any? tags event)</code></div><pre class="doc">Predicate function to check if any of a collection of tags
are present in the tags of event.</pre></div><div class="public" id="var-throttle"><h3>throttle</h3><div class="usage"><code>(throttle n dt &amp; children)</code></div><pre class="doc">Passes on n events every dt seconds. Drops events when necessary.
</pre></div><div class="public" id="var-top"><h3>top</h3><div class="usage"><code>(top k f top-stream)</code><code>(top k f top-stream bottom-stream)</code><code>(top k f top-stream bottom-stream demote?)</code></div><pre class="doc">Bifurcates a stream into a dual pair of streams: one for the top k events,
and one for the bottom k events.

f is a function which maps events to comparable values, e.g. numbers. If an
incoming event e falls in the top k, the top stream receives e and the bottom
stream receives (expire e). If the event is *not* in the top k, calls (top
(expire e)) and (bottom e).

If an inbound event is already expired, it is forwarded directly to both
streams. In this way, both top- and bottom-stream have a consistent, dual
view of the event space.

Index the top 10 events, by metric:

(top 10 :metric index)

Index everything, but tag the top k events with &quot;top&quot;:

(top 10 :metric
  (tag &quot;top&quot; index)
  index)

This implementation of top is lazy, in the sense that it won't proactively
expire events which are bumped from the top-k set--you have to wait for
another event with the same host and service to arrive before child streams
will know it's expired.</pre></div><div class="public" id="var-under"><h3>under</h3><div class="usage"><code>(under x &amp; children)</code></div><pre class="doc">Passes on events only when their metric is smaller than x
</pre></div><div class="public" id="var-where"><h3>where</h3><div class="usage"><code>(where expr &amp; children)</code></div><pre class="doc">Passes on events where expr is true. Expr is rewritten using where-rewrite.
'event is bound to the event under consideration. Examples:

; Match any event where metric is either 1, 2, 3, or 4.
(where (metric 1 2 3 4) ...)

; Match a event where the metric is negative AND the state is ok.
(where (and (&gt; 0 metric)
            (state &quot;ok&quot;)) ...)

; Match a event where the host begins with web
(where (host #&quot;^web&quot;) ...)


; Match an event where the service is in a set of services
(where (service #{&quot;service-foo&quot; &quot;service-bar&quot;}) ...)
; which is equivalent to
(where (service &quot;service-foo&quot; &quot;service-bar&quot;) ...)

If a child begins with (else ...), the else's body is executed when expr is
false. For instance:

(where (service &quot;www&quot;)
  (notify-www-team)
  (else
    (notify-misc-team)))

The streams generated by (where) return the value of expr: truthy if expr
matched the given event, and falsey otherwise. This means (where (metric 5))
tests events and returns true if their metric is five.</pre></div><div class="public" id="var-where*"><h3>where*</h3><div class="usage"><code>(where* f &amp; children)</code></div><pre class="doc">A simpler, less magical variant of (where). Instead of binding symbols in
the context of an expression, where* takes a function which takes an event.
When (f event) is truthy, passes event to children--and otherwise, passes
event to (else ...) children. For example:

(where* (fn [e] (&lt; 2 (:metric e))) prn)

(where* expired?
  (partial prn &quot;Expired&quot;)
  (else
    (partial prn &quot;Not expired!&quot;)))</pre></div><div class="public" id="var-where-partition-clauses"><h3>where-partition-clauses</h3><div class="usage"><code>(where-partition-clauses exprs)</code></div><pre class="doc">Given expressions like (a (else b) c (else d)), returns [[a c] [b d]]
</pre></div><div class="public" id="var-where-rewrite"><h3>where-rewrite</h3><div class="usage"><code>(where-rewrite expr)</code></div><pre class="doc">Rewrites lists recursively. Replaces (metric x y z) with a test matching
(:metric event) to any of x, y, or z, either by = or re-find. Replaces any
other instance of metric with (:metric event). Does the same for host,
service, event, state, time, ttl, tags (which performs an exact match of the
tag vector), tagged (which checks to see if the given tag is present at all),
metric_f, and description.</pre></div><div class="public" id="var-window"><h3>window</h3><div class="usage"><code>(window n &amp; children)</code></div><pre class="doc">Alias for moving-event-window.
</pre></div><div class="public" id="var-with"><h3>with</h3><div class="usage"><code>(with &amp; args)</code></div><pre class="doc">Constructs a copy of each incoming event with new values for the given keys,
and passes the resulting event on to each child stream. As everywhere in
Riemann, events are immutable; only this stream's children will see this
version of the event.

If you only want to set *default* values, use `default`. If you want to
update values for a key based on the *current value* of that field in each
event, use `adjust`. If you want to update events using arbitrary functions,
use `smap`.

; Print each event, but with service &quot;foo&quot;
(with :service &quot;foo&quot; prn)

; Print each event, but with no host and state &quot;broken&quot;.
(with {:host nil :state &quot;broken&quot;} prn)</pre></div><div class="public" id="var-within"><h3>within</h3><div class="usage"><code>(within r &amp; children)</code></div><pre class="doc">Passes on events only when their metric falls within the given inclusive
range.

(within [0 1] (fn [event] do-something))</pre></div><div class="public" id="var-without"><h3>without</h3><div class="usage"><code>(without r &amp; children)</code></div><pre class="doc">Passes on events only when their metric falls outside the given (inclusive)
range.</pre></div></div></body></html>